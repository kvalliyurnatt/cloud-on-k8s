// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License 2.0;
// you may not use this file except in compliance with the Elastic License 2.0.

package main

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/deps"
	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/github"
	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/llm"
	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/parser"
	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/rag"
	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/vulncheck"
	"github.com/spf13/cobra"
)

const (
	defaultGoModPath = "go.mod"
	defaultOwner     = "elastic"
	defaultRepo      = "security"
)

var (
	// Command line flags
	issueNumber   int
	issueTitle    string
	issueBody     string
	goModPath     string
	repoPath      string
	githubToken   string
	nvdAPIKey     string
	owner         string
	repo          string
	dryRun        bool
	addLabels     bool
	skipVulncheck bool

	// LLM Provider flags
	llmProvider  string
	geminiAPIKey string
	geminiModel  string
	ollamaURL    string
	ollamaModel  string

	// RAG flags
	useRAG              bool
	ragProvider         string
	ragIndexPath        string
	ragEmbeddingModel   string
	ragTopK             int
)

func main() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

var rootCmd = &cobra.Command{
	Use:   "cve-triage",
	Short: "CVE triage agent for ECK",
	Long: `CVE Triage Agent for Elastic Cloud on Kubernetes (ECK)

This tool analyzes CVE reports from GitHub issues and determines
if they affect ECK's dependencies or codebase. It uses:
- NVD database for CVE details
- Dependency analysis against ECK's go.mod
- govulncheck for deep vulnerability scanning
- AI analysis (supports multiple providers)

Supported LLM Providers:
  - gemini:  Google Gemini API (requires GEMINI_API_KEY)
  - ollama:  Local LLM via Ollama (free, no API key needed)
  - none:    Basic analysis without AI

Examples:
  # With Gemini (cloud)
  GEMINI_API_KEY=xxx cve-triage --issue-body="CVE-2024-..." --dry-run

  # With Ollama (local, free)
  cve-triage --llm=ollama --issue-body="CVE-2024-..." --dry-run

  # With RAG (requires index)
  cve-triage build-index --repo-path=../..
  cve-triage --llm=ollama --use-rag --issue-body="CVE-2024-..." --dry-run

  # Basic analysis (no LLM)
  cve-triage --llm=none --issue-body="CVE-2024-..." --dry-run
`,
	RunE: runTriage,
}

var buildIndexCmd = &cobra.Command{
	Use:   "build-index",
	Short: "Build RAG vector index from ECK codebase",
	Long: `Build a vector index from the ECK codebase for RAG-enhanced analysis.

This command:
1. Parses all Go source files in the repository
2. Chunks them by function/type definitions
3. Generates embeddings using Ollama (nomic-embed-text)
4. Saves the index to a file for later use

Prerequisites:
  - Ollama must be running: ollama serve
  - Embedding model must be available: ollama pull nomic-embed-text

Example:
  cve-triage build-index --repo-path=../.. --output=data/vectors.gob
`,
	RunE: runBuildIndex,
}

func init() {
	// Add subcommands
	rootCmd.AddCommand(buildIndexCmd)

	// Build-index flags
	buildIndexCmd.Flags().StringVar(&repoPath, "repo-path", "", "Path to ECK repository root (required)")
	buildIndexCmd.Flags().StringVar(&ragIndexPath, "output", "data/vectors.gob", "Output path for vector index")
	buildIndexCmd.Flags().StringVar(&ollamaURL, "ollama-url", "", "Ollama API URL (default: http://localhost:11434)")
	buildIndexCmd.Flags().StringVar(&ragEmbeddingModel, "embedding-model", "", "Embedding model (default: nomic-embed-text)")
	buildIndexCmd.MarkFlagRequired("repo-path")

	// Main command flags
	rootCmd.Flags().IntVar(&issueNumber, "issue-number", 0, "GitHub issue number")
	rootCmd.Flags().StringVar(&issueTitle, "issue-title", "", "GitHub issue title")
	rootCmd.Flags().StringVar(&issueBody, "issue-body", "", "GitHub issue body content")
	rootCmd.Flags().StringVar(&goModPath, "go-mod", defaultGoModPath, "Path to ECK's go.mod file")
	rootCmd.Flags().StringVar(&repoPath, "repo-path", "", "Path to ECK repository root (for govulncheck)")
	rootCmd.Flags().StringVar(&owner, "owner", defaultOwner, "GitHub repository owner")
	rootCmd.Flags().StringVar(&repo, "repo", defaultRepo, "GitHub repository name")
	rootCmd.Flags().BoolVar(&dryRun, "dry-run", false, "Print report to stdout without posting to GitHub")
	rootCmd.Flags().BoolVar(&addLabels, "add-labels", false, "Add triage labels to the issue")
	rootCmd.Flags().BoolVar(&skipVulncheck, "skip-vulncheck", false, "Skip govulncheck scan (faster but less accurate)")

	// Environment variable bindings
	rootCmd.Flags().StringVar(&githubToken, "github-token", "", "GitHub token (or GITHUB_TOKEN env)")
	rootCmd.Flags().StringVar(&nvdAPIKey, "nvd-api-key", "", "NVD API key (or NVD_API_KEY env)")

	// LLM Provider options
	rootCmd.Flags().StringVar(&llmProvider, "llm", "", "LLM provider: gemini, ollama, or none (auto-detected if not set)")
	rootCmd.Flags().StringVar(&geminiAPIKey, "gemini-api-key", "", "Gemini API key (or GEMINI_API_KEY env)")
	rootCmd.Flags().StringVar(&geminiModel, "gemini-model", "", "Gemini model (default: gemini-2.0-flash-lite)")
	rootCmd.Flags().StringVar(&ollamaURL, "ollama-url", "", "Ollama API URL (default: http://localhost:11434)")
	rootCmd.Flags().StringVar(&ollamaModel, "ollama-model", "", "Ollama model (default: llama3.2)")

	// RAG options
	rootCmd.Flags().BoolVar(&useRAG, "use-rag", false, "Enable RAG for enhanced analysis with code context")
	rootCmd.Flags().StringVar(&ragProvider, "rag-provider", "ollama", "RAG provider: ollama (default)")
	rootCmd.Flags().StringVar(&ragIndexPath, "rag-index", "data/vectors.gob", "Path to RAG vector index")
	rootCmd.Flags().StringVar(&ragEmbeddingModel, "rag-embedding-model", "", "Embedding model for RAG (default: nomic-embed-text)")
	rootCmd.Flags().IntVar(&ragTopK, "rag-top-k", 5, "Number of code chunks to retrieve for RAG")
}

func runTriage(cmd *cobra.Command, args []string) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
	defer cancel()

	// Load from environment if not set via flags
	if githubToken == "" {
		githubToken = os.Getenv("GITHUB_TOKEN")
	}
	if geminiAPIKey == "" {
		geminiAPIKey = os.Getenv("GEMINI_API_KEY")
	}
	if nvdAPIKey == "" {
		nvdAPIKey = os.Getenv("NVD_API_KEY")
	}

	// Validate required inputs
	if issueBody == "" && issueTitle == "" {
		return fmt.Errorf("either --issue-body or --issue-title must be provided")
	}

	if !dryRun && githubToken == "" {
		return fmt.Errorf("GitHub token is required (set GITHUB_TOKEN or use --github-token)")
	}

	// Find go.mod path
	goModFullPath, err := findGoMod(goModPath)
	if err != nil {
		return fmt.Errorf("failed to find go.mod: %w", err)
	}

	fmt.Printf("ðŸ” Starting CVE triage analysis...\n\n")

	// Step 1: Parse CVE from issue
	fmt.Printf("ðŸ“‹ Parsing CVE information from issue...\n")
	cveParser := parser.NewParser(nvdAPIKey)
	cveInfo, err := cveParser.ParseFromIssue(ctx, issueTitle, issueBody)
	if err != nil {
		return fmt.Errorf("failed to parse CVE: %w", err)
	}
	fmt.Printf("   Found CVE: %s\n", cveInfo.ID)
	if cveInfo.Severity != "" {
		fmt.Printf("   Severity: %s (CVSS: %.1f)\n", cveInfo.Severity, cveInfo.CVSSScore)
	}

	// Step 2: Check dependencies
	fmt.Printf("\nðŸ“¦ Analyzing ECK dependencies...\n")
	depChecker := deps.NewChecker(goModFullPath)
	if err := depChecker.LoadDependencies(); err != nil {
		return fmt.Errorf("failed to load dependencies: %w", err)
	}
	fmt.Printf("   Loaded %d dependencies from go.mod\n", len(depChecker.GetDependencies()))

	depResult := depChecker.CheckCVE(cveInfo.AffectedPackages, issueBody)
	if depResult.CVEAffectsECK {
		fmt.Printf("   âš ï¸  Found %d direct and %d transitive matches\n",
			len(depResult.DirectMatches), len(depResult.TransitiveMatches))
	} else {
		fmt.Printf("   âœ… No matching dependencies found\n")
	}

	// Step 3: govulncheck scan
	var vulnResult *vulncheck.Result
	if !skipVulncheck {
		fmt.Printf("\nðŸ”’ Running govulncheck scan...\n")

		// Determine repo path for govulncheck
		eckRepoPath := repoPath
		if eckRepoPath == "" {
			eckRepoPath = filepath.Dir(goModFullPath)
		}

		if vulncheck.IsInstalled() {
			scanner := vulncheck.NewScanner(eckRepoPath)
			vulnResult, err = scanner.ScanForCVE(ctx, cveInfo.ID)
			if err != nil {
				fmt.Printf("   âš ï¸  govulncheck failed: %v\n", err)
			} else {
				// Show total vulnerabilities found
				if len(vulnResult.Vulnerabilities) > 0 {
					fmt.Printf("   ðŸ“‹ govulncheck found %d total vulnerability(ies):\n", len(vulnResult.Vulnerabilities))
					for _, v := range vulnResult.Vulnerabilities {
						cveList := ""
						if len(v.CVEs) > 0 {
							cveList = fmt.Sprintf(" (%s)", strings.Join(v.CVEs, ", "))
						}
						fmt.Printf("      - %s%s in %s\n", v.ID, cveList, v.Package)
					}
				}

				// Highlight matches for the specific CVE
				if len(vulnResult.CVEMatches) > 0 {
					fmt.Printf("   ðŸ”´ %d of these match %s:\n", len(vulnResult.CVEMatches), cveInfo.ID)
					for _, v := range vulnResult.CVEMatches {
						fmt.Printf("      - %s in %s\n", v.ID, v.Package)
						if len(v.CalledBy) > 0 {
							fmt.Printf("        Call path: %s\n", strings.Join(v.CalledBy[:min(3, len(v.CalledBy))], " â†’ "))
						}
					}
				} else if len(vulnResult.Vulnerabilities) > 0 {
					fmt.Printf("   âš ï¸  None of these match %s specifically\n", cveInfo.ID)
					fmt.Printf("   ðŸ’¡ Tip: The CVE might be listed under a different ID (e.g., GO-XXXX-XXXX)\n")
				} else {
					fmt.Printf("   âœ… No vulnerabilities found by govulncheck\n")
				}
			}
		} else {
			fmt.Printf("   â„¹ï¸  govulncheck not installed (install with: go install golang.org/x/vuln/cmd/govulncheck@latest)\n")
		}
	} else {
		fmt.Printf("\nðŸ”’ Skipping govulncheck scan (--skip-vulncheck)\n")
	}

	// Step 5: LLM Analysis (optionally with RAG)
	var llmResult *llm.AnalysisResult
	fmt.Printf("\nðŸ¤– Performing AI analysis...\n")

	// Build LLM config
	llmConfig := llm.Config{
		GeminiAPIKey: geminiAPIKey,
		GeminiModel:  geminiModel,
		OllamaURL:    ollamaURL,
		OllamaModel:  ollamaModel,
	}

	// Determine provider
	if llmProvider != "" {
		llmConfig.Provider = llm.ProviderType(llmProvider)
	} else {
		llmConfig.Provider = llm.DetectProvider(llmConfig)
	}

	// Create base LLM provider
	provider, err := llm.NewProvider(ctx, llmConfig)
	if err != nil {
		fmt.Printf("   âš ï¸  Failed to create LLM provider: %v\n", err)
		fmt.Printf("   Falling back to basic analysis\n")
		llmResult = llm.AnalyzeWithoutAPI(cveInfo, depResult, vulnResult)
	} else {
		defer provider.Close()

		// Wrap with RAG if enabled
		if useRAG {
			fmt.Printf("   RAG enabled, loading index from: %s\n", ragIndexPath)
			ragConfig := rag.Config{
				Provider:             rag.ProviderType(ragProvider),
				IndexPath:            ragIndexPath,
				OllamaURL:            ollamaURL,
				OllamaEmbeddingModel: ragEmbeddingModel,
				TopK:                 ragTopK,
			}

			ragProv, err := rag.NewProvider(ctx, ragConfig)
			if err != nil {
				fmt.Printf("   âš ï¸  Failed to create RAG provider: %v\n", err)
				fmt.Printf("   Continuing without RAG\n")
			} else if !ragProv.IsReady(ctx) {
				fmt.Printf("   âš ï¸  RAG index not found or embedder not available\n")
				fmt.Printf("   Run 'build-index' to create the index first\n")
				fmt.Printf("   Continuing without RAG\n")
			} else {
				fmt.Printf("   RAG provider: %s\n", ragProv.Name())
				provider = llm.NewRAGProvider(provider, ragProv, ragTopK)
			}
		}

		fmt.Printf("   Using provider: %s\n", provider.Name())

		if !provider.IsAvailable(ctx) {
			fmt.Printf("   âš ï¸  Provider %s is not available\n", provider.Name())
			if llmConfig.Provider == llm.ProviderOllama {
				fmt.Printf("   To start Ollama: ollama serve\n")
				fmt.Printf("   To pull a model: ollama pull %s\n", llmConfig.OllamaModel)
			}
			fmt.Printf("   Falling back to basic analysis\n")
			llmResult = llm.AnalyzeWithoutAPI(cveInfo, depResult, vulnResult)
		} else {
			llmResult, err = provider.Analyze(ctx, cveInfo, depResult, vulnResult)
			if err != nil {
				fmt.Printf("   âš ï¸  LLM analysis failed: %v\n", err)
				fmt.Printf("   Falling back to basic analysis\n")
				llmResult = llm.AnalyzeWithoutAPI(cveInfo, depResult, vulnResult)
			} else {
				fmt.Printf("   Risk Level: %s\n", llmResult.RiskLevel)
				fmt.Printf("   Confidence: %s\n", llmResult.Confidence)
			}
		}
	}

	// Step 6: Generate report
	report := &github.TriageReport{
		CVEInfo:     cveInfo,
		DepResult:   depResult,
		VulnResult:  vulnResult,
		LLMAnalysis: llmResult,
	}

	// Step 7: Output or post report
	if dryRun {
		fmt.Printf("\n%s", github.FormatReportAsText(report))
		fmt.Printf("\nðŸ“ Dry run mode - report not posted to GitHub\n")
	} else {
		fmt.Printf("\nðŸ“¤ Posting triage report to GitHub...\n")
		reporter := github.NewReporter(ctx, githubToken, owner, repo)

		if err := reporter.PostTriageComment(ctx, issueNumber, report); err != nil {
			return fmt.Errorf("failed to post comment: %w", err)
		}
		fmt.Printf("   âœ… Report posted to issue #%d\n", issueNumber)

		if addLabels {
			if err := reporter.AddLabels(ctx, issueNumber, report); err != nil {
				fmt.Printf("   âš ï¸  Failed to add labels: %v\n", err)
			} else {
				fmt.Printf("   âœ… Labels added to issue\n")
			}
		}
	}

	fmt.Printf("\nâœ… Triage complete!\n")
	return nil
}

// findGoMod locates the go.mod file
func findGoMod(path string) (string, error) {
	// If absolute path, use as is
	if filepath.IsAbs(path) {
		if _, err := os.Stat(path); err != nil {
			return "", err
		}
		return path, nil
	}

	// Try relative to current directory
	if _, err := os.Stat(path); err == nil {
		absPath, _ := filepath.Abs(path)
		return absPath, nil
	}

	// Try to find go.mod by walking up directories
	cwd, err := os.Getwd()
	if err != nil {
		return "", err
	}

	dir := cwd
	for {
		candidate := filepath.Join(dir, "go.mod")
		if _, err := os.Stat(candidate); err == nil {
			return candidate, nil
		}

		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent
	}

	// Check for the ECK repo's go.mod relative to this tool
	// This handles the case when running from hack/cve-triage
	if strings.Contains(cwd, "hack/cve-triage") || strings.Contains(cwd, "hack\\cve-triage") {
		candidate := filepath.Join(cwd, "..", "..", "go.mod")
		if _, err := os.Stat(candidate); err == nil {
			absPath, _ := filepath.Abs(candidate)
			return absPath, nil
		}
	}

	return "", fmt.Errorf("go.mod not found in %s or parent directories", cwd)
}

// runBuildIndex builds the RAG vector index
func runBuildIndex(cmd *cobra.Command, args []string) error {
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Minute)
	defer cancel()

	fmt.Println("ðŸ” Building RAG index for ECK codebase...")
	fmt.Printf("   Repository: %s\n", repoPath)
	fmt.Printf("   Output: %s\n\n", ragIndexPath)

	// Create RAG provider
	ragConfig := rag.Config{
		Provider:             rag.ProviderOllama,
		IndexPath:            ragIndexPath,
		OllamaURL:            ollamaURL,
		OllamaEmbeddingModel: ragEmbeddingModel,
		RepoPath:             repoPath,
	}

	ragProv, err := rag.NewProvider(ctx, ragConfig)
	if err != nil {
		return fmt.Errorf("failed to create RAG provider: %w", err)
	}

	// Check if Ollama is available
	ollamaProv, ok := ragProv.(*rag.OllamaRAGProvider)
	if !ok {
		return fmt.Errorf("expected Ollama RAG provider")
	}

	embedder := ollamaProv.Embedder()
	if !embedder.IsAvailable(ctx) {
		return fmt.Errorf("Ollama is not running or embedding model not available.\nStart Ollama: ollama serve\nPull model: ollama pull nomic-embed-text")
	}

	fmt.Printf("ðŸ“Š Embedding model: %s (dim=%d)\n\n", ollamaProv.Embedder().(*rag.OllamaEmbedder).Model(), embedder.Dimension())

	// Build the index
	fmt.Println("ðŸ“ Chunking and embedding source files...")
	fmt.Println("   This may take several minutes...")

	lastProgress := 0
	err = ollamaProv.BuildIndex(ctx, repoPath, func(current, total int) {
		percent := (current * 100) / total
		if percent >= lastProgress+10 {
			fmt.Printf("   Progress: %d/%d chunks (%d%%)\n", current, total, percent)
			lastProgress = percent
		}
	})
	if err != nil {
		return fmt.Errorf("failed to build index: %w", err)
	}

	fmt.Printf("\nâœ… Index built successfully!\n")
	fmt.Printf("   Indexed %d code chunks\n", ollamaProv.IndexSize())
	fmt.Printf("   Saved to: %s\n", ragIndexPath)
	fmt.Println("\nYou can now use --use-rag to enable RAG-enhanced analysis.")

	return nil
}

