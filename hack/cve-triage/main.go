// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License 2.0;
// you may not use this file except in compliance with the Elastic License 2.0.

package main

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/codefinder"
	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/deps"
	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/extractor"
	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/git"
	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/github"
	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/llm"
	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/parser"
	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/rag"
	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/vulncheck"
	"github.com/spf13/cobra"
)

const (
	defaultGoModPath = "go.mod"
	defaultOwner     = "elastic"
	defaultRepo      = "security"
)

var (
	// Command line flags
	issueNumber   int
	issueTitle    string
	issueBody     string
	goModPath     string
	repoPath      string
	githubToken   string
	nvdAPIKey     string
	owner         string
	repo          string
	dryRun        bool
	addLabels     bool
	skipVulncheck bool

	// LLM Provider flags
	llmProvider  string
	geminiAPIKey string
	geminiModel  string
	ollamaURL    string
	ollamaModel  string

	// RAG flags
	useRAG              bool
	ragProvider         string
	ragIndexPath        string
	ragEmbeddingModel   string
	ragTopK             int

	// Version handling flags
	autoCheckout bool
	eckVersion   string

	// Code inclusion flags
	includeCode bool
	maxCodeSize int

	// Debug flags
	verbose bool
)

func main() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

var rootCmd = &cobra.Command{
	Use:   "cve-triage",
	Short: "CVE triage agent for ECK",
	Long: `CVE Triage Agent for Elastic Cloud on Kubernetes (ECK)

This tool analyzes CVE reports from GitHub issues and determines
if they affect ECK's dependencies or codebase. It uses:
- NVD database for CVE details
- Dependency analysis against ECK's go.mod
- govulncheck for deep vulnerability scanning
- AI analysis (supports multiple providers)

Supported LLM Providers:
  - gemini:  Google Gemini API (requires GEMINI_API_KEY)
  - ollama:  Local LLM via Ollama (free, no API key needed)
  - none:    Basic analysis without AI

Examples:
  # With Gemini (cloud)
  GEMINI_API_KEY=xxx cve-triage --issue-body="CVE-2024-..." --dry-run

  # With Ollama (local, free)
  cve-triage --llm=ollama --issue-body="CVE-2024-..." --dry-run

  # With RAG (requires index)
  cve-triage build-index --repo-path=../..
  cve-triage --llm=ollama --use-rag --issue-body="CVE-2024-..." --dry-run

  # Basic analysis (no LLM)
  cve-triage --llm=none --issue-body="CVE-2024-..." --dry-run

  # Auto-checkout ECK version from issue
  cve-triage --llm=ollama --auto-checkout --issue-body="ECK 3.0.0 CVE-2024-..." --dry-run

  # Override ECK version
  cve-triage --llm=ollama --eck-version=2.14.0 --issue-body="CVE-2024-..." --dry-run
`,
	RunE: runTriage,
}

var buildIndexCmd = &cobra.Command{
	Use:   "build-index",
	Short: "Build RAG vector index from ECK codebase",
	Long: `Build a vector index from the ECK codebase for RAG-enhanced analysis.

This command:
1. Parses all Go source files in the repository
2. Chunks them by function/type definitions
3. Generates embeddings using Ollama (nomic-embed-text)
4. Saves the index to a file for later use

Prerequisites:
  - Ollama must be running: ollama serve
  - Embedding model must be available: ollama pull nomic-embed-text

Example:
  # Build index for current code
  cve-triage build-index --repo-path=../.. --output=data/vectors.gob

  # Build version-specific index (e.g., for ECK 3.0.0)
  cve-triage build-index --repo-path=../.. --version=3.0.0
`,
	RunE: runBuildIndex,
}

func init() {
	// Add subcommands
	rootCmd.AddCommand(buildIndexCmd)

	// Build-index flags
	buildIndexCmd.Flags().StringVar(&repoPath, "repo-path", "", "Path to ECK repository root (required)")
	buildIndexCmd.Flags().StringVar(&ragIndexPath, "output", "data/vectors.gob", "Output path for vector index")
	buildIndexCmd.Flags().StringVar(&ollamaURL, "ollama-url", "", "Ollama API URL (default: http://localhost:11434)")
	buildIndexCmd.Flags().StringVar(&ragEmbeddingModel, "embedding-model", "", "Embedding model (default: nomic-embed-text)")
	buildIndexCmd.Flags().StringVar(&eckVersion, "version", "", "ECK version to index (adds version suffix to output path)")
	buildIndexCmd.MarkFlagRequired("repo-path")

	// Main command flags
	rootCmd.Flags().IntVar(&issueNumber, "issue-number", 0, "GitHub issue number")
	rootCmd.Flags().StringVar(&issueTitle, "issue-title", "", "GitHub issue title")
	rootCmd.Flags().StringVar(&issueBody, "issue-body", "", "GitHub issue body content")
	rootCmd.Flags().StringVar(&goModPath, "go-mod", defaultGoModPath, "Path to ECK's go.mod file")
	rootCmd.Flags().StringVar(&repoPath, "repo-path", "", "Path to ECK repository root (for govulncheck)")
	rootCmd.Flags().StringVar(&owner, "owner", defaultOwner, "GitHub repository owner")
	rootCmd.Flags().StringVar(&repo, "repo", defaultRepo, "GitHub repository name")
	rootCmd.Flags().BoolVar(&dryRun, "dry-run", false, "Print report to stdout without posting to GitHub")
	rootCmd.Flags().BoolVar(&addLabels, "add-labels", false, "Add triage labels to the issue")
	rootCmd.Flags().BoolVar(&skipVulncheck, "skip-vulncheck", false, "Skip govulncheck scan (faster but less accurate)")

	// Environment variable bindings
	rootCmd.Flags().StringVar(&githubToken, "github-token", "", "GitHub token (or GITHUB_TOKEN env)")
	rootCmd.Flags().StringVar(&nvdAPIKey, "nvd-api-key", "", "NVD API key (or NVD_API_KEY env)")

	// LLM Provider options
	rootCmd.Flags().StringVar(&llmProvider, "llm", "", "LLM provider: gemini, ollama, or none (auto-detected if not set)")
	rootCmd.Flags().StringVar(&geminiAPIKey, "gemini-api-key", "", "Gemini API key (or GEMINI_API_KEY env)")
	rootCmd.Flags().StringVar(&geminiModel, "gemini-model", "", "Gemini model (default: gemini-2.0-flash-lite)")
	rootCmd.Flags().StringVar(&ollamaURL, "ollama-url", "", "Ollama API URL (default: http://localhost:11434)")
	rootCmd.Flags().StringVar(&ollamaModel, "ollama-model", "", "Ollama model (default: llama3.2)")

	// RAG options
	rootCmd.Flags().BoolVar(&useRAG, "use-rag", false, "Enable RAG for enhanced analysis with code context")
	rootCmd.Flags().StringVar(&ragProvider, "rag-provider", "ollama", "RAG provider: ollama (default)")
	rootCmd.Flags().StringVar(&ragIndexPath, "rag-index", "data/vectors.gob", "Path to RAG vector index")
	rootCmd.Flags().StringVar(&ragEmbeddingModel, "rag-embedding-model", "", "Embedding model for RAG (default: nomic-embed-text)")
	rootCmd.Flags().IntVar(&ragTopK, "rag-top-k", 5, "Number of code chunks to retrieve for RAG")

	// Version handling options
	rootCmd.Flags().BoolVar(&autoCheckout, "auto-checkout", false, "Auto-checkout ECK version extracted from issue")
	rootCmd.Flags().StringVar(&eckVersion, "eck-version", "", "Override ECK version (skips extraction)")

	// Code inclusion options
	rootCmd.Flags().BoolVar(&includeCode, "include-code", true, "Include relevant ECK source files in LLM analysis")
	rootCmd.Flags().IntVar(&maxCodeSize, "max-code-size", 500*1024, "Maximum code to include in bytes (default: 500KB)")

	// Debug options
	rootCmd.Flags().BoolVar(&verbose, "verbose", false, "Show detailed output including LLM prompts and responses")
}

func runTriage(cmd *cobra.Command, args []string) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
	defer cancel()

	// Load from environment if not set via flags
	if githubToken == "" {
		githubToken = os.Getenv("GITHUB_TOKEN")
	}
	if geminiAPIKey == "" {
		geminiAPIKey = os.Getenv("GEMINI_API_KEY")
	}
	if nvdAPIKey == "" {
		nvdAPIKey = os.Getenv("NVD_API_KEY")
	}

	// Validate required inputs
	if issueBody == "" && issueTitle == "" {
		return fmt.Errorf("either --issue-body or --issue-title must be provided")
	}

	if !dryRun && githubToken == "" {
		return fmt.Errorf("GitHub token is required (set GITHUB_TOKEN or use --github-token)")
	}

	// Find go.mod path
	goModFullPath, err := findGoMod(goModPath)
	if err != nil {
		return fmt.Errorf("failed to find go.mod: %w", err)
	}

	// Determine repo path for govulncheck and git operations
	eckRepoPath := repoPath
	if eckRepoPath == "" {
		eckRepoPath = filepath.Dir(goModFullPath)
	}

	fmt.Printf("ðŸ” Starting CVE triage analysis...\n\n")

	// Build LLM config early (needed for extraction)
	llmConfig := llm.Config{
		GeminiAPIKey: geminiAPIKey,
		GeminiModel:  geminiModel,
		OllamaURL:    ollamaURL,
		OllamaModel:  ollamaModel,
		Verbose:      verbose,
	}

	// Determine LLM provider
	if llmProvider != "" {
		llmConfig.Provider = llm.ProviderType(llmProvider)
	} else {
		llmConfig.Provider = llm.DetectProvider(llmConfig)
	}

	// Create LLM provider (may be nil if llmProvider == "none")
	var provider llm.Provider
	if llmConfig.Provider != llm.ProviderNone {
		provider, err = llm.NewProvider(ctx, llmConfig)
		if err != nil {
			fmt.Printf("   âš ï¸  Failed to create LLM provider: %v\n", err)
			fmt.Printf("   Continuing without LLM\n")
		} else {
			defer provider.Close()
		}
	}

	// Step 1: Extract structured information from issue
	fmt.Printf("ðŸ“‹ Extracting information from issue...\n")
	issueExtractor := extractor.NewExtractor()
	extractedInfo := issueExtractor.Extract(ctx, provider, issueTitle, issueBody)
	
	fmt.Printf("   Extracted by: %s\n", extractedInfo.ExtractedBy)
	if len(extractedInfo.CVEIDs) > 0 {
		fmt.Printf("   CVE IDs: %v\n", extractedInfo.CVEIDs)
	}
	if extractedInfo.ECKVersion != "" {
		fmt.Printf("   ECK Version: %s\n", extractedInfo.ECKVersion)
	}
	if len(extractedInfo.AffectedPackages) > 0 {
		fmt.Printf("   Affected packages: %v\n", extractedInfo.AffectedPackages)
	}
	if extractedInfo.Severity != "" {
		fmt.Printf("   Severity: %s\n", extractedInfo.Severity)
	}

	// Determine target ECK version
	targetVersion := eckVersion // CLI override takes precedence
	if targetVersion == "" && extractedInfo.ECKVersion != "" {
		targetVersion = extractedInfo.ECKVersion
	}

	// Step 2: Handle version checkout if requested
	var versionHandler *git.VersionHandler
	if autoCheckout && targetVersion != "" {
		fmt.Printf("\nðŸ”€ Checking out ECK version %s...\n", targetVersion)
		versionHandler, err = git.NewVersionHandler(eckRepoPath)
		if err != nil {
			fmt.Printf("   âš ï¸  Failed to initialize git handler: %v\n", err)
			fmt.Printf("   Continuing with current code\n")
		} else {
			if err := versionHandler.CheckoutVersion(targetVersion); err != nil {
				fmt.Printf("   âš ï¸  Failed to checkout version %s: %v\n", targetVersion, err)
				fmt.Printf("   Continuing with current code\n")
			} else {
				fmt.Printf("   âœ… Checked out: %s\n", versionHandler.GetCurrentVersion())
				defer func() {
					fmt.Printf("\nðŸ”€ Restoring original git state...\n")
					if err := versionHandler.RestoreOriginal(); err != nil {
						fmt.Printf("   âš ï¸  Failed to restore: %v\n", err)
					} else {
						fmt.Printf("   âœ… Restored to: %s\n", versionHandler.OriginalRef())
					}
				}()
			}
		}
	}

	// Step 3: Parse CVE from NVD (using extracted CVE ID or regex fallback)
	fmt.Printf("\nðŸ“‹ Fetching CVE information from NVD...\n")
	cveParser := parser.NewParser(nvdAPIKey)
	
	// Use extracted CVE ID if available
	var cveIDForParsing string
	if len(extractedInfo.CVEIDs) > 0 {
		cveIDForParsing = extractedInfo.CVEIDs[0]
	}
	
	var cveInfo *parser.CVEInfo
	if cveIDForParsing != "" {
		// Fetch from NVD using extracted CVE ID
		cveInfo, err = cveParser.ParseFromIssue(ctx, cveIDForParsing, issueBody)
	} else {
		// Fall back to regex parsing
		cveInfo, err = cveParser.ParseFromIssue(ctx, issueTitle, issueBody)
	}
	
	if err != nil {
		return fmt.Errorf("failed to parse CVE: %w", err)
	}
	fmt.Printf("   Found CVE: %s\n", cveInfo.ID)
	if cveInfo.Severity != "" {
		fmt.Printf("   Severity: %s (CVSS: %.1f)\n", cveInfo.Severity, cveInfo.CVSSScore)
	}

	// Step 4: Check dependencies
	fmt.Printf("\nðŸ“¦ Analyzing ECK dependencies...\n")
	depChecker := deps.NewChecker(goModFullPath)
	if err := depChecker.LoadDependencies(); err != nil {
		return fmt.Errorf("failed to load dependencies: %w", err)
	}
	fmt.Printf("   Loaded %d dependencies from go.mod\n", len(depChecker.GetDependencies()))

	depResult := depChecker.CheckCVE(cveInfo.AffectedPackages, issueBody)
	if depResult.CVEAffectsECK {
		fmt.Printf("   âš ï¸  Found %d direct and %d transitive matches\n",
			len(depResult.DirectMatches), len(depResult.TransitiveMatches))
	} else {
		fmt.Printf("   âœ… No matching dependencies found\n")
	}

	// Step 5: govulncheck scan
	var vulnResult *vulncheck.Result
	if !skipVulncheck {
		fmt.Printf("\nðŸ”’ Running govulncheck scan...\n")

		if vulncheck.IsInstalled() {
			scanner := vulncheck.NewScanner(eckRepoPath)
			vulnResult, err = scanner.ScanForCVE(ctx, cveInfo.ID)
			if err != nil {
				fmt.Printf("   âš ï¸  govulncheck failed: %v\n", err)
			} else {
				// Show total vulnerabilities found
				if len(vulnResult.Vulnerabilities) > 0 {
					fmt.Printf("   ðŸ“‹ govulncheck found %d total vulnerability(ies):\n", len(vulnResult.Vulnerabilities))
					for _, v := range vulnResult.Vulnerabilities {
						cveList := ""
						if len(v.CVEs) > 0 {
							cveList = fmt.Sprintf(" (%s)", strings.Join(v.CVEs, ", "))
						}
						fmt.Printf("      - %s%s in %s\n", v.ID, cveList, v.Package)
					}
				}

				// Highlight matches for the specific CVE
				if len(vulnResult.CVEMatches) > 0 {
					fmt.Printf("   ðŸ”´ %d of these match %s:\n", len(vulnResult.CVEMatches), cveInfo.ID)
					for _, v := range vulnResult.CVEMatches {
						fmt.Printf("      - %s in %s\n", v.ID, v.Package)
						if len(v.CalledBy) > 0 {
							fmt.Printf("        Call path: %s\n", strings.Join(v.CalledBy[:min(3, len(v.CalledBy))], " â†’ "))
						}
					}
				} else if len(vulnResult.Vulnerabilities) > 0 {
					fmt.Printf("   âš ï¸  None of these match %s specifically\n", cveInfo.ID)
					fmt.Printf("   ðŸ’¡ Tip: The CVE might be listed under a different ID (e.g., GO-XXXX-XXXX)\n")
				} else {
					fmt.Printf("   âœ… No vulnerabilities found by govulncheck\n")
				}
			}
		} else {
			fmt.Printf("   â„¹ï¸  govulncheck not installed (install with: go install golang.org/x/vuln/cmd/govulncheck@latest)\n")
		}
	} else {
		fmt.Printf("\nðŸ”’ Skipping govulncheck scan (--skip-vulncheck)\n")
	}

	// Step 6: Find relevant source code (if enabled)
	var codeContext string
	if includeCode && provider != nil {
		fmt.Printf("\nðŸ“„ Finding relevant source code...\n")

		// Collect packages to search for from multiple sources
		packagesToFind := make([]string, 0)
		seenPkgs := make(map[string]bool)

		addPackage := func(pkg string) {
			if pkg != "" && !seenPkgs[pkg] {
				packagesToFind = append(packagesToFind, pkg)
				seenPkgs[pkg] = true
			}
		}

		// From NVD data
		for _, pkg := range cveInfo.AffectedPackages {
			addPackage(pkg)
		}

		// From LLM extraction
		for _, pkg := range extractedInfo.AffectedPackages {
			addPackage(pkg)
		}

		// From dependency matches (this is key - if we matched a dep, search for it)
		for _, m := range depResult.DirectMatches {
			addPackage(m.MatchedPackage)
			addPackage(m.Dependency.Path)
		}
		for _, m := range depResult.TransitiveMatches {
			addPackage(m.MatchedPackage)
			addPackage(m.Dependency.Path)
		}

		// From govulncheck results (if it found matching vulnerabilities)
		if vulnResult != nil {
			for _, v := range vulnResult.CVEMatches {
				addPackage(v.Package)
			}
			// Also check all vulnerabilities in case we want broader context
			for _, v := range vulnResult.Vulnerabilities {
				// Only add if it's in the CVE matches (already confirmed relevant)
				for _, match := range vulnResult.CVEMatches {
					if v.ID == match.ID {
						addPackage(v.Package)
					}
				}
			}
		}

		if len(packagesToFind) > 0 {
			fmt.Printf("   Searching for imports: %v\n", packagesToFind)
			finder := codefinder.NewCodeFinder(eckRepoPath)
			codeFiles, err := finder.FindAndRead(packagesToFind, maxCodeSize)
			if err != nil {
				fmt.Printf("   âš ï¸  Failed to find code: %v\n", err)
			} else if len(codeFiles) > 0 {
				fileCount, lineCount, byteCount := codefinder.GetStats(codeFiles)
				fmt.Printf("   Found %d files importing affected packages\n", fileCount)
				fmt.Printf("   Including %d lines (%d KB) of code context\n", lineCount, byteCount/1024)
				codeContext = codefinder.FormatForPrompt(codeFiles)
			} else {
				fmt.Printf("   No files found importing: %v\n", packagesToFind)
			}
		} else {
			fmt.Printf("   No affected packages to search for\n")
		}
	}

	// Step 7: LLM Analysis (optionally with RAG)
	var llmResult *llm.AnalysisResult
	fmt.Printf("\nðŸ¤– Performing AI analysis...\n")

	// Determine version-aware RAG index path
	effectiveRAGIndexPath := ragIndexPath
	if useRAG && targetVersion != "" {
		effectiveRAGIndexPath = rag.VersionedIndexPath(ragIndexPath, targetVersion)
		fmt.Printf("   Using version-specific RAG index: %s\n", effectiveRAGIndexPath)
	}

	if provider == nil {
		// No LLM provider available
		fmt.Printf("   No LLM provider available\n")
		fmt.Printf("   Using basic analysis\n")
		llmResult = llm.AnalyzeWithoutAPI(cveInfo, depResult, vulnResult)
	} else {
		// Wrap with RAG if enabled
		analysisProvider := provider
		if useRAG {
			fmt.Printf("   RAG enabled, loading index from: %s\n", effectiveRAGIndexPath)
			ragConfig := rag.Config{
				Provider:             rag.ProviderType(ragProvider),
				IndexPath:            effectiveRAGIndexPath,
				OllamaURL:            ollamaURL,
				OllamaEmbeddingModel: ragEmbeddingModel,
				TopK:                 ragTopK,
			}

			ragProv, err := rag.NewProvider(ctx, ragConfig)
			if err != nil {
				fmt.Printf("   âš ï¸  Failed to create RAG provider: %v\n", err)
				fmt.Printf("   Continuing without RAG\n")
			} else if !ragProv.IsReady(ctx) {
				fmt.Printf("   âš ï¸  RAG index not found or embedder not available\n")
				fmt.Printf("   Run 'build-index' to create the index first\n")
				fmt.Printf("   Continuing without RAG\n")
			} else {
				fmt.Printf("   RAG provider: %s\n", ragProv.Name())
				analysisProvider = llm.NewRAGProvider(provider, ragProv, ragTopK)
			}
		}

		fmt.Printf("   Using provider: %s\n", analysisProvider.Name())
		if codeContext != "" {
			fmt.Printf("   Code context: included\n")
		}

		if !analysisProvider.IsAvailable(ctx) {
			fmt.Printf("   âš ï¸  Provider %s is not available\n", analysisProvider.Name())
			if llmConfig.Provider == llm.ProviderOllama {
				fmt.Printf("   To start Ollama: ollama serve\n")
				fmt.Printf("   To pull a model: ollama pull %s\n", llmConfig.OllamaModel)
			}
			fmt.Printf("   Falling back to basic analysis\n")
			llmResult = llm.AnalyzeWithoutAPI(cveInfo, depResult, vulnResult)
		} else {
			// Use AnalyzeWithCode if we have code context, otherwise standard Analyze
			if codeContext != "" {
				llmResult, err = analysisProvider.AnalyzeWithCode(ctx, cveInfo, depResult, vulnResult, codeContext)
			} else {
				llmResult, err = analysisProvider.Analyze(ctx, cveInfo, depResult, vulnResult)
			}
			if err != nil {
				fmt.Printf("   âš ï¸  LLM analysis failed: %v\n", err)
				fmt.Printf("   Falling back to basic analysis\n")
				llmResult = llm.AnalyzeWithoutAPI(cveInfo, depResult, vulnResult)
			} else {
				fmt.Printf("   Risk Level: %s\n", llmResult.RiskLevel)
				fmt.Printf("   Confidence: %s\n", llmResult.Confidence)
			}
		}
	}

	// Step 8: Generate report
	report := &github.TriageReport{
		CVEInfo:     cveInfo,
		DepResult:   depResult,
		VulnResult:  vulnResult,
		LLMAnalysis: llmResult,
	}

	// Step 9: Output or post report
	if dryRun {
		fmt.Printf("\n%s", github.FormatReportAsText(report))
		fmt.Printf("\nðŸ“ Dry run mode - report not posted to GitHub\n")
	} else {
		fmt.Printf("\nðŸ“¤ Posting triage report to GitHub...\n")
		reporter := github.NewReporter(ctx, githubToken, owner, repo)

		if err := reporter.PostTriageComment(ctx, issueNumber, report); err != nil {
			return fmt.Errorf("failed to post comment: %w", err)
		}
		fmt.Printf("   âœ… Report posted to issue #%d\n", issueNumber)

		if addLabels {
			if err := reporter.AddLabels(ctx, issueNumber, report); err != nil {
				fmt.Printf("   âš ï¸  Failed to add labels: %v\n", err)
			} else {
				fmt.Printf("   âœ… Labels added to issue\n")
			}
		}
	}

	fmt.Printf("\nâœ… Triage complete!\n")
	return nil
}

// findGoMod locates the go.mod file
func findGoMod(path string) (string, error) {
	// If absolute path, use as is
	if filepath.IsAbs(path) {
		if _, err := os.Stat(path); err != nil {
			return "", err
		}
		return path, nil
	}

	// Try relative to current directory
	if _, err := os.Stat(path); err == nil {
		absPath, _ := filepath.Abs(path)
		return absPath, nil
	}

	// Try to find go.mod by walking up directories
	cwd, err := os.Getwd()
	if err != nil {
		return "", err
	}

	dir := cwd
	for {
		candidate := filepath.Join(dir, "go.mod")
		if _, err := os.Stat(candidate); err == nil {
			return candidate, nil
		}

		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent
	}

	// Check for the ECK repo's go.mod relative to this tool
	// This handles the case when running from hack/cve-triage
	if strings.Contains(cwd, "hack/cve-triage") || strings.Contains(cwd, "hack\\cve-triage") {
		candidate := filepath.Join(cwd, "..", "..", "go.mod")
		if _, err := os.Stat(candidate); err == nil {
			absPath, _ := filepath.Abs(candidate)
			return absPath, nil
		}
	}

	return "", fmt.Errorf("go.mod not found in %s or parent directories", cwd)
}

// runBuildIndex builds the RAG vector index
func runBuildIndex(cmd *cobra.Command, args []string) error {
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Minute)
	defer cancel()

	// Determine version-aware output path
	effectiveOutputPath := ragIndexPath
	if eckVersion != "" {
		effectiveOutputPath = rag.VersionedIndexPath(ragIndexPath, eckVersion)
	}

	fmt.Println("ðŸ” Building RAG index for ECK codebase...")
	fmt.Printf("   Repository: %s\n", repoPath)
	if eckVersion != "" {
		fmt.Printf("   Version: %s\n", eckVersion)
	}
	fmt.Printf("   Output: %s\n\n", effectiveOutputPath)

	// Handle version checkout if specified
	var versionHandler *git.VersionHandler
	if eckVersion != "" {
		var err error
		versionHandler, err = git.NewVersionHandler(repoPath)
		if err != nil {
			return fmt.Errorf("failed to initialize git handler: %w", err)
		}

		if err := versionHandler.CheckoutVersion(eckVersion); err != nil {
			return fmt.Errorf("failed to checkout version %s: %w", eckVersion, err)
		}
		fmt.Printf("   âœ… Checked out: %s\n\n", versionHandler.GetCurrentVersion())

		defer func() {
			fmt.Printf("\nðŸ”€ Restoring original git state...\n")
			if err := versionHandler.RestoreOriginal(); err != nil {
				fmt.Printf("   âš ï¸  Failed to restore: %v\n", err)
			} else {
				fmt.Printf("   âœ… Restored to: %s\n", versionHandler.OriginalRef())
			}
		}()
	}

	// Create RAG provider
	ragConfig := rag.Config{
		Provider:             rag.ProviderOllama,
		IndexPath:            effectiveOutputPath,
		OllamaURL:            ollamaURL,
		OllamaEmbeddingModel: ragEmbeddingModel,
		RepoPath:             repoPath,
	}

	ragProv, err := rag.NewProvider(ctx, ragConfig)
	if err != nil {
		return fmt.Errorf("failed to create RAG provider: %w", err)
	}

	// Check if Ollama is available
	ollamaProv, ok := ragProv.(*rag.OllamaRAGProvider)
	if !ok {
		return fmt.Errorf("expected Ollama RAG provider")
	}

	embedder := ollamaProv.Embedder()
	if !embedder.IsAvailable(ctx) {
		return fmt.Errorf("Ollama is not running or embedding model not available.\nStart Ollama: ollama serve\nPull model: ollama pull nomic-embed-text")
	}

	fmt.Printf("ðŸ“Š Embedding model: %s (dim=%d)\n\n", ollamaProv.Embedder().(*rag.OllamaEmbedder).Model(), embedder.Dimension())

	// Build the index
	fmt.Println("ðŸ“ Chunking and embedding source files...")
	fmt.Println("   This may take several minutes...")

	lastProgress := 0
	err = ollamaProv.BuildIndex(ctx, repoPath, func(current, total int) {
		percent := (current * 100) / total
		if percent >= lastProgress+10 {
			fmt.Printf("   Progress: %d/%d chunks (%d%%)\n", current, total, percent)
			lastProgress = percent
		}
	})
	if err != nil {
		return fmt.Errorf("failed to build index: %w", err)
	}

	fmt.Printf("\nâœ… Index built successfully!\n")
	fmt.Printf("   Indexed %d code chunks\n", ollamaProv.IndexSize())
	fmt.Printf("   Saved to: %s\n", effectiveOutputPath)
	fmt.Println("\nYou can now use --use-rag to enable RAG-enhanced analysis.")

	return nil
}

