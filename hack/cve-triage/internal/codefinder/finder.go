// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License 2.0;
// you may not use this file except in compliance with the Elastic License 2.0.

package codefinder

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
)

// CodeFinder finds and reads source files based on imports
type CodeFinder struct {
	repoPath string
}

// FileContent represents a file and its content
type FileContent struct {
	Path    string
	Content string
	Size    int
	Lines   int
}

// NewCodeFinder creates a new code finder for the given repository
func NewCodeFinder(repoPath string) *CodeFinder {
	// Convert to absolute path
	absPath, err := filepath.Abs(repoPath)
	if err == nil {
		repoPath = absPath
	}
	return &CodeFinder{
		repoPath: repoPath,
	}
}

// FindFilesImporting finds Go files that import any of the given packages
func (f *CodeFinder) FindFilesImporting(packages []string) ([]string, error) {
	if len(packages) == 0 {
		return nil, nil
	}

	// Build regex patterns for import matching
	patterns := make([]*regexp.Regexp, 0, len(packages))
	for _, pkg := range packages {
		// Escape special regex chars and create pattern
		// Match both direct imports and subpackages
		escaped := regexp.QuoteMeta(pkg)
		pattern := regexp.MustCompile(`"` + escaped + `(/[^"]*)?"|` + escaped)
		patterns = append(patterns, pattern)
	}

	var matchingFiles []string
	seen := make(map[string]bool)

	err := filepath.Walk(f.repoPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return nil // Skip errors
		}

		// Skip directories we don't want to scan
		if info.IsDir() {
			name := info.Name()
			if name == "vendor" || name == ".git" || name == "hack" || 
			   name == "testdata" || strings.HasPrefix(name, ".") {
				return filepath.SkipDir
			}
			return nil
		}

		// Only process .go files, skip tests
		if !strings.HasSuffix(path, ".go") {
			return nil
		}
		if strings.HasSuffix(path, "_test.go") {
			return nil
		}
		if strings.Contains(path, "zz_generated") {
			return nil
		}

		// Check if file imports any of the packages
		if f.fileImportsAny(path, patterns) {
			relPath, _ := filepath.Rel(f.repoPath, path)
			if !seen[relPath] {
				matchingFiles = append(matchingFiles, relPath)
				seen[relPath] = true
			}
		}

		return nil
	})

	// Sort for consistent ordering
	sort.Strings(matchingFiles)

	return matchingFiles, err
}

// fileImportsAny checks if a file imports any of the given packages
func (f *CodeFinder) fileImportsAny(filePath string, patterns []*regexp.Regexp) bool {
	file, err := os.Open(filePath)
	if err != nil {
		return false
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	inImportBlock := false

	for scanner.Scan() {
		line := scanner.Text()
		trimmed := strings.TrimSpace(line)

		// Track import blocks
		if strings.HasPrefix(trimmed, "import (") {
			inImportBlock = true
			continue
		}
		if inImportBlock && trimmed == ")" {
			inImportBlock = false
			continue
		}

		// Check single-line imports
		if strings.HasPrefix(trimmed, "import ") {
			for _, pattern := range patterns {
				if pattern.MatchString(line) {
					return true
				}
			}
		}

		// Check imports within import block
		if inImportBlock {
			for _, pattern := range patterns {
				if pattern.MatchString(line) {
					return true
				}
			}
		}

		// Stop after imports section (optimization)
		if !inImportBlock && !strings.HasPrefix(trimmed, "import") && 
		   !strings.HasPrefix(trimmed, "package") && 
		   !strings.HasPrefix(trimmed, "//") && 
		   !strings.HasPrefix(trimmed, "/*") &&
		   trimmed != "" {
			// We've passed the import section
			break
		}
	}

	return false
}

// ReadFiles reads the contents of the given files up to maxBytes total
func (f *CodeFinder) ReadFiles(paths []string, maxBytes int) ([]FileContent, error) {
	var contents []FileContent
	totalBytes := 0

	for _, relPath := range paths {
		if totalBytes >= maxBytes {
			break
		}

		fullPath := filepath.Join(f.repoPath, relPath)
		data, err := os.ReadFile(fullPath)
		if err != nil {
			continue // Skip files we can't read
		}

		content := string(data)
		size := len(data)

		// Truncate if needed to stay within budget
		if totalBytes+size > maxBytes {
			remaining := maxBytes - totalBytes
			if remaining > 100 { // Only include if we can fit something meaningful
				content = content[:remaining] + "\n// ... truncated ..."
				size = remaining
			} else {
				break
			}
		}

		lines := strings.Count(content, "\n") + 1

		contents = append(contents, FileContent{
			Path:    relPath,
			Content: content,
			Size:    size,
			Lines:   lines,
		})

		totalBytes += size
	}

	return contents, nil
}

// FormatForPrompt formats file contents for inclusion in an LLM prompt
func FormatForPrompt(files []FileContent) string {
	if len(files) == 0 {
		return ""
	}

	var sb strings.Builder
	totalLines := 0
	totalSize := 0

	for _, file := range files {
		totalLines += file.Lines
		totalSize += file.Size
	}

	sb.WriteString(fmt.Sprintf("The following %d ECK source files (%d lines, %d bytes) are relevant to this CVE:\n\n",
		len(files), totalLines, totalSize))

	for _, file := range files {
		sb.WriteString(fmt.Sprintf("### File: `%s` (%d lines)\n\n", file.Path, file.Lines))
		sb.WriteString("```go\n")
		sb.WriteString(file.Content)
		if !strings.HasSuffix(file.Content, "\n") {
			sb.WriteString("\n")
		}
		sb.WriteString("```\n\n")
	}

	return sb.String()
}

// FindAndRead is a convenience method that finds and reads files in one call
func (f *CodeFinder) FindAndRead(packages []string, maxBytes int) ([]FileContent, error) {
	files, err := f.FindFilesImporting(packages)
	if err != nil {
		return nil, err
	}

	return f.ReadFiles(files, maxBytes)
}

// GetStats returns statistics about the found files
func GetStats(files []FileContent) (fileCount int, totalLines int, totalBytes int) {
	for _, f := range files {
		fileCount++
		totalLines += f.Lines
		totalBytes += f.Size
	}
	return
}

