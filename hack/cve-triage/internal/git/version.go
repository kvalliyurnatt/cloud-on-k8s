// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License 2.0;
// you may not use this file except in compliance with the Elastic License 2.0.

package git

import (
	"bytes"
	"fmt"
	"os/exec"
	"strings"
)

// VersionHandler manages git version checkout and restoration
type VersionHandler struct {
	repoPath       string
	originalRef    string
	checkedOutRef  string
	hasCheckedOut  bool
}

// NewVersionHandler creates a new version handler for the given repository
func NewVersionHandler(repoPath string) (*VersionHandler, error) {
	vh := &VersionHandler{
		repoPath: repoPath,
	}

	// Store the current ref (branch or commit)
	currentRef, err := vh.getCurrentRef()
	if err != nil {
		return nil, fmt.Errorf("failed to get current git ref: %w", err)
	}
	vh.originalRef = currentRef

	return vh, nil
}

// getCurrentRef returns the current branch name or commit hash
func (v *VersionHandler) getCurrentRef() (string, error) {
	// Try to get the branch name first
	cmd := exec.Command("git", "-C", v.repoPath, "rev-parse", "--abbrev-ref", "HEAD")
	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return "", fmt.Errorf("git rev-parse failed: %s", stderr.String())
	}

	ref := strings.TrimSpace(stdout.String())
	
	// If HEAD is detached, get the commit hash
	if ref == "HEAD" {
		cmd = exec.Command("git", "-C", v.repoPath, "rev-parse", "HEAD")
		stdout.Reset()
		stderr.Reset()
		cmd.Stdout = &stdout
		cmd.Stderr = &stderr

		if err := cmd.Run(); err != nil {
			return "", fmt.Errorf("git rev-parse HEAD failed: %s", stderr.String())
		}
		ref = strings.TrimSpace(stdout.String())
	}

	return ref, nil
}

// CheckoutVersion checks out the specified ECK version
// It tries multiple formats: v{version}, {version}, release-{majorMinor}
func (v *VersionHandler) CheckoutVersion(version string) error {
	if version == "" {
		return nil
	}

	// Normalize version (add 'v' prefix if needed for tag lookup)
	candidates := v.versionCandidates(version)

	var lastErr error
	for _, candidate := range candidates {
		if v.refExists(candidate) {
			if err := v.checkout(candidate); err != nil {
				lastErr = err
				continue
			}
			v.checkedOutRef = candidate
			v.hasCheckedOut = true
			return nil
		}
	}

	if lastErr != nil {
		return fmt.Errorf("failed to checkout version %s: %w", version, lastErr)
	}
	return fmt.Errorf("version %s not found (tried: %v)", version, candidates)
}

// versionCandidates returns a list of possible git refs for the given version
func (v *VersionHandler) versionCandidates(version string) []string {
	// Normalize: remove 'v' prefix if present
	version = strings.TrimPrefix(version, "v")
	version = strings.TrimPrefix(version, "V")

	candidates := []string{
		"v" + version,           // v3.0.0
		version,                 // 3.0.0
	}

	// Add branch candidate for major.minor
	parts := strings.Split(version, ".")
	if len(parts) >= 2 {
		majorMinor := parts[0] + "." + parts[1]
		candidates = append(candidates, "release-"+majorMinor) // release-3.0
	}

	return candidates
}

// refExists checks if a git ref (tag or branch) exists
func (v *VersionHandler) refExists(ref string) bool {
	cmd := exec.Command("git", "-C", v.repoPath, "rev-parse", "--verify", "--quiet", ref)
	return cmd.Run() == nil
}

// checkout performs the actual git checkout
func (v *VersionHandler) checkout(ref string) error {
	cmd := exec.Command("git", "-C", v.repoPath, "checkout", ref)
	var stderr bytes.Buffer
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("git checkout %s failed: %s", ref, stderr.String())
	}

	return nil
}

// RestoreOriginal restores the original git ref
func (v *VersionHandler) RestoreOriginal() error {
	if !v.hasCheckedOut {
		return nil
	}

	if err := v.checkout(v.originalRef); err != nil {
		return fmt.Errorf("failed to restore original ref %s: %w", v.originalRef, err)
	}

	v.hasCheckedOut = false
	return nil
}

// GetCurrentVersion returns the checked-out version or empty string
func (v *VersionHandler) GetCurrentVersion() string {
	if v.hasCheckedOut {
		return v.checkedOutRef
	}
	return ""
}

// OriginalRef returns the original ref before any checkout
func (v *VersionHandler) OriginalRef() string {
	return v.originalRef
}

// HasCheckedOut returns true if a version checkout was performed
func (v *VersionHandler) HasCheckedOut() bool {
	return v.hasCheckedOut
}

// ListTags returns available tags matching the pattern
func (v *VersionHandler) ListTags(pattern string) ([]string, error) {
	args := []string{"-C", v.repoPath, "tag", "-l"}
	if pattern != "" {
		args = append(args, pattern)
	}

	cmd := exec.Command("git", args...)
	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return nil, fmt.Errorf("git tag -l failed: %s", stderr.String())
	}

	lines := strings.Split(strings.TrimSpace(stdout.String()), "\n")
	var tags []string
	for _, line := range lines {
		if line != "" {
			tags = append(tags, line)
		}
	}

	return tags, nil
}

