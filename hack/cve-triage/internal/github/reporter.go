// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License 2.0;
// you may not use this file except in compliance with the Elastic License 2.0.

package github

import (
	"context"
	"fmt"
	"strings"

	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/deps"
	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/llm"
	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/parser"
	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/vulncheck"
	gh "github.com/google/go-github/v60/github"
	"golang.org/x/oauth2"
)

// Reporter posts triage results to GitHub issues
type Reporter struct {
	client *gh.Client
	owner  string
	repo   string
}

// NewReporter creates a new GitHub reporter
func NewReporter(ctx context.Context, token, owner, repo string) *Reporter {
	ts := oauth2.StaticTokenSource(
		&oauth2.Token{AccessToken: token},
	)
	tc := oauth2.NewClient(ctx, ts)
	client := gh.NewClient(tc)

	return &Reporter{
		client: client,
		owner:  owner,
		repo:   repo,
	}
}

// TriageReport contains all the information for a triage report
type TriageReport struct {
	CVEInfo      *parser.CVEInfo
	DepResult    *deps.CheckResult
	VulnResult   *vulncheck.Result
	LLMAnalysis  *llm.AnalysisResult
}

// PostTriageComment posts a formatted triage report as a comment on the issue
func (r *Reporter) PostTriageComment(ctx context.Context, issueNumber int, report *TriageReport) error {
	comment := formatTriageReport(report)

	_, _, err := r.client.Issues.CreateComment(ctx, r.owner, r.repo, issueNumber, &gh.IssueComment{
		Body: &comment,
	})
	if err != nil {
		return fmt.Errorf("failed to post comment: %w", err)
	}

	return nil
}

// formatTriageReport creates a markdown-formatted triage report
func formatTriageReport(report *TriageReport) string {
	var sb strings.Builder

	sb.WriteString("## üîç ECK CVE Triage Report\n\n")

	// CVE Header
	sb.WriteString(fmt.Sprintf("**CVE**: %s\n", report.CVEInfo.ID))
	if report.CVEInfo.Severity != "" {
		sb.WriteString(fmt.Sprintf("**Severity**: %s", report.CVEInfo.Severity))
		if report.CVEInfo.CVSSScore > 0 {
			sb.WriteString(fmt.Sprintf(" (CVSS: %.1f)", report.CVEInfo.CVSSScore))
		}
		sb.WriteString("\n")
	}
	if report.CVEInfo.PublishedDate != "" {
		sb.WriteString(fmt.Sprintf("**Published**: %s\n", report.CVEInfo.PublishedDate))
	}
	sb.WriteString("\n")

	// Risk Assessment Badge
	if report.LLMAnalysis != nil {
		riskEmoji := getRiskEmoji(report.LLMAnalysis.RiskLevel)
		sb.WriteString(fmt.Sprintf("### %s Risk Level: **%s**\n\n", riskEmoji, report.LLMAnalysis.RiskLevel))
	}

	// Description
	if report.CVEInfo.Description != "" {
		sb.WriteString("### CVE Description\n\n")
		sb.WriteString(report.CVEInfo.Description)
		sb.WriteString("\n\n")
	}

	// Dependency Analysis
	sb.WriteString("### Dependency Analysis\n\n")
	if report.DepResult != nil {
		if !report.DepResult.CVEAffectsECK && len(report.DepResult.DirectMatches) == 0 && len(report.DepResult.TransitiveMatches) == 0 {
			sb.WriteString("‚úÖ No matching dependencies found in ECK's `go.mod`.\n\n")
		} else {
			if len(report.DepResult.DirectMatches) > 0 {
				sb.WriteString("**Direct Dependencies:**\n")
				for _, m := range report.DepResult.DirectMatches {
					status := "‚ö†Ô∏è"
					if !m.IsVulnerable {
						status = "‚úÖ"
					}
					sb.WriteString(fmt.Sprintf("- %s `%s@%s`", status, m.Dependency.Path, m.Dependency.Version))
					if m.MatchedPackage != "" {
						sb.WriteString(fmt.Sprintf(" (matched: %s)", m.MatchedPackage))
					}
					if m.VulnerabilityNote != "" {
						sb.WriteString(fmt.Sprintf("\n  - %s", m.VulnerabilityNote))
					}
					sb.WriteString("\n")
				}
				sb.WriteString("\n")
			} else {
				sb.WriteString("- **Direct dependency match**: No\n")
			}

			if len(report.DepResult.TransitiveMatches) > 0 {
				sb.WriteString("**Transitive (Indirect) Dependencies:**\n")
				for _, m := range report.DepResult.TransitiveMatches {
					status := "‚ö†Ô∏è"
					if !m.IsVulnerable {
						status = "‚úÖ"
					}
					sb.WriteString(fmt.Sprintf("- %s `%s@%s`", status, m.Dependency.Path, m.Dependency.Version))
					if m.MatchedPackage != "" {
						sb.WriteString(fmt.Sprintf(" (matched: %s)", m.MatchedPackage))
					}
					if m.VulnerabilityNote != "" {
						sb.WriteString(fmt.Sprintf("\n  - %s", m.VulnerabilityNote))
					}
					sb.WriteString("\n")
				}
				sb.WriteString("\n")
			} else if len(report.DepResult.DirectMatches) == 0 {
				sb.WriteString("- **Transitive dependency match**: No\n\n")
			}
		}
	}

	// govulncheck Results
	if report.VulnResult != nil {
		sb.WriteString("### govulncheck Scan\n\n")

		if len(report.VulnResult.CVEMatches) > 0 {
			sb.WriteString(fmt.Sprintf("üî¥ **Found %d vulnerability match(es) for this CVE:**\n\n", len(report.VulnResult.CVEMatches)))
			for _, v := range report.VulnResult.CVEMatches {
				sb.WriteString(fmt.Sprintf("- **%s**", v.ID))
				if len(v.CVEs) > 0 {
					sb.WriteString(fmt.Sprintf(" (%s)", strings.Join(v.CVEs, ", ")))
				}
				sb.WriteString("\n")
				if v.Package != "" {
					sb.WriteString(fmt.Sprintf("  - Package: `%s`\n", v.Package))
				}
				if v.FixedIn != "" {
					sb.WriteString(fmt.Sprintf("  - Fixed in: `%s`\n", v.FixedIn))
				}
				if len(v.CalledBy) > 0 {
					sb.WriteString("  - Call path: ")
					maxFrames := 4
					if len(v.CalledBy) < maxFrames {
						maxFrames = len(v.CalledBy)
					}
					sb.WriteString("`" + strings.Join(v.CalledBy[:maxFrames], "` ‚Üí `") + "`")
					if len(v.CalledBy) > maxFrames {
						sb.WriteString(" ‚Üí ...")
					}
					sb.WriteString("\n")
				}
				if v.Description != "" {
					sb.WriteString(fmt.Sprintf("  - %s\n", v.Description))
				}
			}
			sb.WriteString("\n")
		} else if len(report.VulnResult.Vulnerabilities) > 0 {
			sb.WriteString(fmt.Sprintf("‚ö†Ô∏è Found %d other vulnerabilities (not matching this specific CVE):\n\n", len(report.VulnResult.Vulnerabilities)))
			sb.WriteString("<details>\n<summary>View other vulnerabilities</summary>\n\n")
			for _, v := range report.VulnResult.Vulnerabilities {
				sb.WriteString(fmt.Sprintf("- %s", v.ID))
				if len(v.CVEs) > 0 {
					sb.WriteString(fmt.Sprintf(" (%s)", strings.Join(v.CVEs, ", ")))
				}
				if v.Package != "" {
					sb.WriteString(fmt.Sprintf(" in `%s`", v.Package))
				}
				sb.WriteString("\n")
			}
			sb.WriteString("\n</details>\n\n")
		} else {
			sb.WriteString("‚úÖ govulncheck found no vulnerabilities affecting ECK.\n\n")
		}
	}

	// LLM Analysis
	if report.LLMAnalysis != nil {
		sb.WriteString("### AI Analysis\n\n")

		if report.LLMAnalysis.Summary != "" {
			sb.WriteString("**Summary:**\n")
			sb.WriteString(report.LLMAnalysis.Summary)
			sb.WriteString("\n\n")
		}

		if report.LLMAnalysis.DetailedAnalysis != "" {
			sb.WriteString("<details>\n<summary>Detailed Analysis</summary>\n\n")
			sb.WriteString(report.LLMAnalysis.DetailedAnalysis)
			sb.WriteString("\n\n</details>\n\n")
		}

		if len(report.LLMAnalysis.AffectedAreas) > 0 {
			sb.WriteString("**Potentially Affected ECK Areas:**\n")
			for _, area := range report.LLMAnalysis.AffectedAreas {
				sb.WriteString(fmt.Sprintf("- %s\n", area))
			}
			sb.WriteString("\n")
		}

		if report.LLMAnalysis.ExploitationScenario != "" {
			sb.WriteString("<details>\n<summary>Exploitation Scenario</summary>\n\n")
			sb.WriteString(report.LLMAnalysis.ExploitationScenario)
			sb.WriteString("\n\n</details>\n\n")
		}

		if report.LLMAnalysis.Recommendation != "" {
			sb.WriteString("### Recommendation\n\n")
			sb.WriteString(report.LLMAnalysis.Recommendation)
			sb.WriteString("\n\n")
		}

		sb.WriteString(fmt.Sprintf("*Analysis Confidence: %s*\n\n", report.LLMAnalysis.Confidence))
	}

	// References
	if len(report.CVEInfo.References) > 0 {
		sb.WriteString("### References\n\n")
		// Limit to first 5 references
		maxRefs := 5
		if len(report.CVEInfo.References) < maxRefs {
			maxRefs = len(report.CVEInfo.References)
		}
		for i := 0; i < maxRefs; i++ {
			sb.WriteString(fmt.Sprintf("- %s\n", report.CVEInfo.References[i]))
		}
		if len(report.CVEInfo.References) > 5 {
			sb.WriteString(fmt.Sprintf("- ... and %d more\n", len(report.CVEInfo.References)-5))
		}
		sb.WriteString("\n")
	}

	// Footer
	sb.WriteString("---\n")
	sb.WriteString("*This is an automated triage report. Please verify the findings manually before taking action.*\n")

	return sb.String()
}

// getRiskEmoji returns an appropriate emoji for the risk level
func getRiskEmoji(riskLevel string) string {
	switch strings.ToUpper(riskLevel) {
	case "HIGH":
		return "üî¥"
	case "MEDIUM":
		return "üü†"
	case "LOW":
		return "üü°"
	case "NONE":
		return "üü¢"
	default:
		return "‚ö™"
	}
}

// AddLabels adds labels to an issue based on triage results
func (r *Reporter) AddLabels(ctx context.Context, issueNumber int, report *TriageReport) error {
	var labels []string

	// Add risk level label
	if report.LLMAnalysis != nil {
		switch strings.ToUpper(report.LLMAnalysis.RiskLevel) {
		case "HIGH":
			labels = append(labels, "security:high")
		case "MEDIUM":
			labels = append(labels, "security:medium")
		case "LOW":
			labels = append(labels, "security:low")
		case "NONE":
			labels = append(labels, "security:not-affected")
		}
	}

	// Add triaged label
	labels = append(labels, "triaged")

	if len(labels) > 0 {
		_, _, err := r.client.Issues.AddLabelsToIssue(ctx, r.owner, r.repo, issueNumber, labels)
		if err != nil {
			return fmt.Errorf("failed to add labels: %w", err)
		}
	}

	return nil
}

// GetIssue fetches an issue by number
func (r *Reporter) GetIssue(ctx context.Context, issueNumber int) (*gh.Issue, error) {
	issue, _, err := r.client.Issues.Get(ctx, r.owner, r.repo, issueNumber)
	if err != nil {
		return nil, fmt.Errorf("failed to get issue: %w", err)
	}
	return issue, nil
}

// FormatReportAsText returns the report as plain text (for CLI output)
func FormatReportAsText(report *TriageReport) string {
	var sb strings.Builder

	sb.WriteString("=" + strings.Repeat("=", 60) + "\n")
	sb.WriteString("ECK CVE TRIAGE REPORT\n")
	sb.WriteString("=" + strings.Repeat("=", 60) + "\n\n")

	sb.WriteString(fmt.Sprintf("CVE: %s\n", report.CVEInfo.ID))
	if report.CVEInfo.Severity != "" {
		sb.WriteString(fmt.Sprintf("Severity: %s (CVSS: %.1f)\n", report.CVEInfo.Severity, report.CVEInfo.CVSSScore))
	}
	sb.WriteString("\n")

	if report.LLMAnalysis != nil {
		sb.WriteString(fmt.Sprintf("RISK LEVEL: %s\n", report.LLMAnalysis.RiskLevel))
		sb.WriteString(fmt.Sprintf("Confidence: %s\n", report.LLMAnalysis.Confidence))
		sb.WriteString("\n")
	}

	sb.WriteString("DESCRIPTION:\n")
	sb.WriteString(report.CVEInfo.Description)
	sb.WriteString("\n\n")

	sb.WriteString("DEPENDENCY ANALYSIS:\n")
	if report.DepResult != nil {
		sb.WriteString(report.DepResult.Summary)
	}
	sb.WriteString("\n")

	sb.WriteString("\nGOVULNCHECK SCAN:\n")
	if report.VulnResult != nil {
		if len(report.VulnResult.CVEMatches) > 0 {
			sb.WriteString(fmt.Sprintf("FOUND %d MATCH(ES) FOR THIS CVE:\n", len(report.VulnResult.CVEMatches)))
			for _, v := range report.VulnResult.CVEMatches {
				sb.WriteString(fmt.Sprintf("  - %s in %s\n", v.ID, v.Package))
				if v.FixedIn != "" {
					sb.WriteString(fmt.Sprintf("    Fixed in: %s\n", v.FixedIn))
				}
			}
		} else if len(report.VulnResult.Vulnerabilities) > 0 {
			sb.WriteString(fmt.Sprintf("Found %d other vulnerabilities (not matching this CVE)\n", len(report.VulnResult.Vulnerabilities)))
		} else {
			sb.WriteString("No vulnerabilities found\n")
		}
	} else {
		sb.WriteString("Scan not performed\n")
	}

	if report.LLMAnalysis != nil {
		sb.WriteString("\nAI ANALYSIS:\n")
		if report.LLMAnalysis.Summary != "" {
			sb.WriteString("Summary: ")
			sb.WriteString(report.LLMAnalysis.Summary)
			sb.WriteString("\n\n")
		}

		if report.LLMAnalysis.DetailedAnalysis != "" {
			sb.WriteString("Detailed Analysis:\n")
			sb.WriteString(report.LLMAnalysis.DetailedAnalysis)
			sb.WriteString("\n\n")
		}

		if len(report.LLMAnalysis.AffectedAreas) > 0 {
			sb.WriteString("Affected Areas:\n")
			for _, area := range report.LLMAnalysis.AffectedAreas {
				sb.WriteString(fmt.Sprintf("  - %s\n", area))
			}
			sb.WriteString("\n")
		}

		if report.LLMAnalysis.ExploitationScenario != "" {
			sb.WriteString("Exploitation Scenario:\n")
			sb.WriteString(report.LLMAnalysis.ExploitationScenario)
			sb.WriteString("\n\n")
		}

		if report.LLMAnalysis.Recommendation != "" {
			sb.WriteString("RECOMMENDATION:\n")
			sb.WriteString(report.LLMAnalysis.Recommendation)
			sb.WriteString("\n")
		}
	}

	sb.WriteString("\n" + strings.Repeat("=", 61) + "\n")

	return sb.String()
}

