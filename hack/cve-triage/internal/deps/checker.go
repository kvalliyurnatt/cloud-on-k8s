// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License 2.0;
// you may not use this file except in compliance with the Elastic License 2.0.

package deps

import (
	"bufio"
	"fmt"
	"os"
	"strings"

	"golang.org/x/mod/modfile"
	"golang.org/x/mod/semver"
)

// Dependency represents a Go module dependency
type Dependency struct {
	Path     string `json:"path"`
	Version  string `json:"version"`
	Indirect bool   `json:"indirect"`
}

// CheckResult contains the results of a dependency check against a CVE
type CheckResult struct {
	CVEAffectsECK      bool          `json:"cveAffectsECK"`
	DirectMatches      []DependencyMatch `json:"directMatches"`
	TransitiveMatches  []DependencyMatch `json:"transitiveMatches"`
	AllDependencies    []Dependency      `json:"allDependencies"`
	Summary            string            `json:"summary"`
}

// DependencyMatch represents a dependency that matches a CVE's affected packages
type DependencyMatch struct {
	Dependency        Dependency `json:"dependency"`
	MatchedPackage    string     `json:"matchedPackage"`
	AffectedVersions  string     `json:"affectedVersions"`
	IsVulnerable      bool       `json:"isVulnerable"`
	VulnerabilityNote string     `json:"vulnerabilityNote"`
}

// Checker handles dependency analysis
type Checker struct {
	goModPath string
	deps      []Dependency
}

// NewChecker creates a new dependency checker
func NewChecker(goModPath string) *Checker {
	return &Checker{
		goModPath: goModPath,
	}
}

// LoadDependencies parses the go.mod file and loads all dependencies
func (c *Checker) LoadDependencies() error {
	content, err := os.ReadFile(c.goModPath)
	if err != nil {
		return fmt.Errorf("failed to read go.mod: %w", err)
	}

	modFile, err := modfile.Parse(c.goModPath, content, nil)
	if err != nil {
		return fmt.Errorf("failed to parse go.mod: %w", err)
	}

	c.deps = make([]Dependency, 0, len(modFile.Require))
	for _, req := range modFile.Require {
		c.deps = append(c.deps, Dependency{
			Path:     req.Mod.Path,
			Version:  req.Mod.Version,
			Indirect: req.Indirect,
		})
	}

	return nil
}

// GetDependencies returns all loaded dependencies
func (c *Checker) GetDependencies() []Dependency {
	return c.deps
}

// CheckCVE checks if any dependencies match the CVE's affected packages
func (c *Checker) CheckCVE(affectedPackages []string, issueBody string) *CheckResult {
	result := &CheckResult{
		AllDependencies: c.deps,
	}

	// Also try to extract package names from the issue body
	additionalPackages := extractPackageNamesFromText(issueBody)
	allAffectedPackages := append(affectedPackages, additionalPackages...)

	for _, dep := range c.deps {
		for _, affected := range allAffectedPackages {
			if matchesPackage(dep.Path, affected) {
				match := DependencyMatch{
					Dependency:     dep,
					MatchedPackage: affected,
					IsVulnerable:   true, // We'll refine this with version checks if available
				}

				if dep.Indirect {
					result.TransitiveMatches = append(result.TransitiveMatches, match)
				} else {
					result.DirectMatches = append(result.DirectMatches, match)
				}
			}
		}
	}

	result.CVEAffectsECK = len(result.DirectMatches) > 0 || len(result.TransitiveMatches) > 0
	result.Summary = c.generateSummary(result)

	return result
}

// CheckCVEWithVersions checks dependencies with version range information
func (c *Checker) CheckCVEWithVersions(packageVersions map[string]string) *CheckResult {
	result := &CheckResult{
		AllDependencies: c.deps,
	}

	for _, dep := range c.deps {
		for pkg, affectedVersionRange := range packageVersions {
			if matchesPackage(dep.Path, pkg) {
				isVuln := isVersionVulnerable(dep.Version, affectedVersionRange)
				match := DependencyMatch{
					Dependency:       dep,
					MatchedPackage:   pkg,
					AffectedVersions: affectedVersionRange,
					IsVulnerable:     isVuln,
				}

				if isVuln {
					match.VulnerabilityNote = fmt.Sprintf("ECK uses %s which is within the affected range %s", dep.Version, affectedVersionRange)
				} else {
					match.VulnerabilityNote = fmt.Sprintf("ECK uses %s which is outside the affected range %s", dep.Version, affectedVersionRange)
				}

				if dep.Indirect {
					result.TransitiveMatches = append(result.TransitiveMatches, match)
				} else {
					result.DirectMatches = append(result.DirectMatches, match)
				}
			}
		}
	}

	// Only consider it affecting ECK if there are vulnerable matches
	for _, m := range result.DirectMatches {
		if m.IsVulnerable {
			result.CVEAffectsECK = true
			break
		}
	}
	if !result.CVEAffectsECK {
		for _, m := range result.TransitiveMatches {
			if m.IsVulnerable {
				result.CVEAffectsECK = true
				break
			}
		}
	}

	result.Summary = c.generateSummary(result)

	return result
}

// matchesPackage checks if a Go module path matches an affected package identifier
func matchesPackage(modPath, affected string) bool {
	// Normalize both strings
	modPath = strings.ToLower(modPath)
	affected = strings.ToLower(affected)

	// Direct match
	if modPath == affected {
		return true
	}

	// Check if the module path contains the affected package name
	// This handles cases like "golang.org/x/crypto" matching "crypto"
	parts := strings.Split(modPath, "/")
	for _, part := range parts {
		if part == affected {
			return true
		}
	}

	// Check if affected is a prefix (subpackage)
	if strings.HasPrefix(modPath, affected) || strings.HasPrefix(affected, modPath) {
		return true
	}

	// Handle vendor/product format from CPE
	if strings.Contains(affected, "/") {
		affectedParts := strings.Split(affected, "/")
		if len(affectedParts) >= 2 {
			product := affectedParts[len(affectedParts)-1]
			for _, part := range parts {
				if part == product {
					return true
				}
			}
		}
	}

	return false
}

// isVersionVulnerable checks if a version is within an affected range
// affectedRange format examples: "< 1.0.0", ">= 1.0.0, < 2.0.0", "1.0.0"
func isVersionVulnerable(version, affectedRange string) bool {
	// Normalize version to semver format
	if !strings.HasPrefix(version, "v") {
		version = "v" + version
	}

	// Parse the affected range
	affectedRange = strings.TrimSpace(affectedRange)

	// Handle compound ranges (e.g., ">= 1.0.0, < 2.0.0")
	if strings.Contains(affectedRange, ",") {
		parts := strings.Split(affectedRange, ",")
		for _, part := range parts {
			if !checkVersionCondition(version, strings.TrimSpace(part)) {
				return false
			}
		}
		return true
	}

	return checkVersionCondition(version, affectedRange)
}

// checkVersionCondition checks a single version condition
func checkVersionCondition(version, condition string) bool {
	condition = strings.TrimSpace(condition)

	if strings.HasPrefix(condition, "<=") {
		target := normalizeVersion(strings.TrimPrefix(condition, "<="))
		return semver.Compare(version, target) <= 0
	}
	if strings.HasPrefix(condition, ">=") {
		target := normalizeVersion(strings.TrimPrefix(condition, ">="))
		return semver.Compare(version, target) >= 0
	}
	if strings.HasPrefix(condition, "<") {
		target := normalizeVersion(strings.TrimPrefix(condition, "<"))
		return semver.Compare(version, target) < 0
	}
	if strings.HasPrefix(condition, ">") {
		target := normalizeVersion(strings.TrimPrefix(condition, ">"))
		return semver.Compare(version, target) > 0
	}
	if strings.HasPrefix(condition, "=") {
		target := normalizeVersion(strings.TrimPrefix(condition, "="))
		return semver.Compare(version, target) == 0
	}

	// Exact version match
	target := normalizeVersion(condition)
	return semver.Compare(version, target) == 0
}

// normalizeVersion ensures a version string is in semver format
func normalizeVersion(v string) string {
	v = strings.TrimSpace(v)
	if !strings.HasPrefix(v, "v") {
		v = "v" + v
	}
	return v
}

// generateSummary creates a human-readable summary of the check results
func (c *Checker) generateSummary(result *CheckResult) string {
	var sb strings.Builder

	if !result.CVEAffectsECK {
		if len(result.DirectMatches) == 0 && len(result.TransitiveMatches) == 0 {
			sb.WriteString("No matching dependencies found in ECK's go.mod.")
		} else {
			sb.WriteString("Matching dependencies found but none are in the vulnerable version range.")
		}
		return sb.String()
	}

	if len(result.DirectMatches) > 0 {
		sb.WriteString(fmt.Sprintf("Found %d direct dependency match(es):\n", len(result.DirectMatches)))
		for _, m := range result.DirectMatches {
			sb.WriteString(fmt.Sprintf("  - %s@%s (matched: %s)\n", m.Dependency.Path, m.Dependency.Version, m.MatchedPackage))
			if m.VulnerabilityNote != "" {
				sb.WriteString(fmt.Sprintf("    Note: %s\n", m.VulnerabilityNote))
			}
		}
	}

	if len(result.TransitiveMatches) > 0 {
		sb.WriteString(fmt.Sprintf("Found %d transitive (indirect) dependency match(es):\n", len(result.TransitiveMatches)))
		for _, m := range result.TransitiveMatches {
			sb.WriteString(fmt.Sprintf("  - %s@%s (matched: %s)\n", m.Dependency.Path, m.Dependency.Version, m.MatchedPackage))
			if m.VulnerabilityNote != "" {
				sb.WriteString(fmt.Sprintf("    Note: %s\n", m.VulnerabilityNote))
			}
		}
	}

	return sb.String()
}

// extractPackageNamesFromText tries to find Go package names in text
func extractPackageNamesFromText(text string) []string {
	var packages []string
	seen := make(map[string]bool)

	// Common patterns for Go packages
	patterns := []string{
		"golang.org/x/",
		"github.com/",
		"k8s.io/",
		"sigs.k8s.io/",
		"google.golang.org/",
	}

	scanner := bufio.NewScanner(strings.NewReader(text))
	scanner.Split(bufio.ScanWords)

	for scanner.Scan() {
		word := strings.Trim(scanner.Text(), "`,\"'()[]{}:;")
		for _, pattern := range patterns {
			if strings.HasPrefix(word, pattern) {
				// Extract the package path (up to version or space)
				pkg := word
				if idx := strings.Index(pkg, "@"); idx > 0 {
					pkg = pkg[:idx]
				}
				if !seen[pkg] {
					seen[pkg] = true
					packages = append(packages, pkg)
				}
				break
			}
		}
	}

	return packages
}

// GetDirectDependencies returns only direct (non-indirect) dependencies
func (c *Checker) GetDirectDependencies() []Dependency {
	var direct []Dependency
	for _, dep := range c.deps {
		if !dep.Indirect {
			direct = append(direct, dep)
		}
	}
	return direct
}

// GetTransitiveDependencies returns only indirect/transitive dependencies
func (c *Checker) GetTransitiveDependencies() []Dependency {
	var transitive []Dependency
	for _, dep := range c.deps {
		if dep.Indirect {
			transitive = append(transitive, dep)
		}
	}
	return transitive
}

// FindDependency looks up a specific dependency by path
func (c *Checker) FindDependency(path string) *Dependency {
	path = strings.ToLower(path)
	for _, dep := range c.deps {
		if strings.ToLower(dep.Path) == path {
			return &dep
		}
	}
	return nil
}

