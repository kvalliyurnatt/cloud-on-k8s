// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License 2.0;
// you may not use this file except in compliance with the Elastic License 2.0.

package llm

import (
	"context"
	"fmt"
	"strings"

	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/deps"
	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/parser"
	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/vulncheck"
	"github.com/google/generative-ai-go/genai"
	"google.golang.org/api/option"
)

// AnalysisResult contains the LLM's analysis of the CVE
type AnalysisResult struct {
	RiskLevel            string   `json:"riskLevel"`            // HIGH, MEDIUM, LOW, NONE
	Summary              string   `json:"summary"`              // Brief summary
	DetailedAnalysis     string   `json:"detailedAnalysis"`     // Full analysis
	AffectedAreas        []string `json:"affectedAreas"`        // Parts of ECK that might be affected
	ExploitationScenario string   `json:"exploitationScenario"` // How the vulnerability could be exploited
	Recommendation       string   `json:"recommendation"`       // Suggested action
	Confidence           string   `json:"confidence"`           // HIGH, MEDIUM, LOW
}

// Analyzer uses Gemini to analyze CVE impact on ECK
type Analyzer struct {
	client    *genai.Client
	model     *genai.GenerativeModel
	modelName string
	verbose   bool
}

// Ensure Analyzer implements Provider interface
var _ Provider = (*Analyzer)(nil)

// DefaultModel is the default Gemini model to use
// See available models: https://ai.google.dev/models/gemini
// Current options (Dec 2024): gemini-2.0-flash-lite, gemini-2.5-flash, gemini-2.5-pro
const DefaultModel = "gemini-2.0-flash-lite"

// NewAnalyzer creates a new LLM analyzer with Gemini
func NewAnalyzer(ctx context.Context, apiKey string) (*Analyzer, error) {
	return NewAnalyzerWithModel(ctx, apiKey, DefaultModel)
}

// NewAnalyzerWithModel creates a new LLM analyzer with a specific model
func NewAnalyzerWithModel(ctx context.Context, apiKey, modelName string) (*Analyzer, error) {
	client, err := genai.NewClient(ctx, option.WithAPIKey(apiKey))
	if err != nil {
		return nil, fmt.Errorf("failed to create Gemini client: %w", err)
	}

	if modelName == "" {
		modelName = DefaultModel
	}

	model := client.GenerativeModel(modelName)
	model.SetTemperature(0.2) // Low temperature for more deterministic responses
	model.SetTopP(0.8)

	return &Analyzer{
		client:    client,
		model:     model,
		modelName: modelName,
	}, nil
}

// Name returns the provider name
func (a *Analyzer) Name() string {
	return fmt.Sprintf("Gemini (%s)", a.modelName)
}

// IsAvailable checks if Gemini is available (always true if client was created)
func (a *Analyzer) IsAvailable(ctx context.Context) bool {
	return a.client != nil && a.model != nil
}

// Close releases the Gemini client resources
func (a *Analyzer) Close() error {
	return a.client.Close()
}

// Analyze performs LLM-based analysis of the CVE's impact on ECK
func (a *Analyzer) Analyze(ctx context.Context, cveInfo *parser.CVEInfo, depResult *deps.CheckResult, vulnResult *vulncheck.Result) (*AnalysisResult, error) {
	prompt := buildAnalysisPrompt(cveInfo, depResult, vulnResult)
	return a.analyzeWithPrompt(ctx, prompt)
}

// AnalyzeWithCode performs LLM-based analysis with source code context
func (a *Analyzer) AnalyzeWithCode(ctx context.Context, cveInfo *parser.CVEInfo, depResult *deps.CheckResult, vulnResult *vulncheck.Result, codeContext string) (*AnalysisResult, error) {
	prompt := BuildAnalysisPromptWithCode(cveInfo, depResult, vulnResult, codeContext)
	return a.analyzeWithPrompt(ctx, prompt)
}

// analyzeWithPrompt performs analysis with a custom prompt (used by RAG)
func (a *Analyzer) analyzeWithPrompt(ctx context.Context, prompt string) (*AnalysisResult, error) {
	resp, err := a.model.GenerateContent(ctx, genai.Text(prompt))
	if err != nil {
		return nil, fmt.Errorf("failed to generate analysis: %w", err)
	}

	if len(resp.Candidates) == 0 || len(resp.Candidates[0].Content.Parts) == 0 {
		return nil, fmt.Errorf("no response from Gemini")
	}

	// Extract text from response
	var responseText string
	for _, part := range resp.Candidates[0].Content.Parts {
		if text, ok := part.(genai.Text); ok {
			responseText += string(text)
		}
	}

	if a.verbose {
		fmt.Printf("\n=== RAW LLM RESPONSE ===\n%s\n=== END RAW RESPONSE ===\n\n", responseText)
	}

	return parseAnalysisResponse(responseText), nil
}

// GenerateRaw sends a prompt and returns the raw text response
func (a *Analyzer) GenerateRaw(ctx context.Context, prompt string) (string, error) {
	resp, err := a.model.GenerateContent(ctx, genai.Text(prompt))
	if err != nil {
		return "", fmt.Errorf("failed to generate content: %w", err)
	}

	if len(resp.Candidates) == 0 || len(resp.Candidates[0].Content.Parts) == 0 {
		return "", fmt.Errorf("no response from Gemini")
	}

	var responseText string
	for _, part := range resp.Candidates[0].Content.Parts {
		if text, ok := part.(genai.Text); ok {
			responseText += string(text)
		}
	}

	return responseText, nil
}

// buildAnalysisPrompt creates the prompt for CVE analysis
func buildAnalysisPrompt(cveInfo *parser.CVEInfo, depResult *deps.CheckResult, vulnResult *vulncheck.Result) string {
	return BuildAnalysisPromptWithCode(cveInfo, depResult, vulnResult, "")
}

// BuildAnalysisPromptWithCode creates the prompt for CVE analysis with optional code context
func BuildAnalysisPromptWithCode(cveInfo *parser.CVEInfo, depResult *deps.CheckResult, vulnResult *vulncheck.Result, codeContext string) string {
	var sb strings.Builder

	sb.WriteString(`You are a security analyst specializing in Kubernetes operators and Go applications. 
Analyze the following CVE and determine its impact on ECK (Elastic Cloud on Kubernetes).

ECK is a Kubernetes operator that manages Elasticsearch, Kibana, APM Server, Enterprise Search, 
Beats, Elastic Agent, Elastic Maps Server, and Logstash deployments on Kubernetes.

`)

	sb.WriteString("## CVE Information\n\n")
	sb.WriteString(fmt.Sprintf("**CVE ID**: %s\n", cveInfo.ID))
	sb.WriteString(fmt.Sprintf("**Severity**: %s (CVSS: %.1f)\n", cveInfo.Severity, cveInfo.CVSSScore))
	sb.WriteString(fmt.Sprintf("**Description**: %s\n\n", cveInfo.Description))

	if len(cveInfo.AffectedPackages) > 0 {
		sb.WriteString("**Affected Packages** (from NVD):\n")
		for _, pkg := range cveInfo.AffectedPackages {
			sb.WriteString(fmt.Sprintf("- %s\n", pkg))
		}
		sb.WriteString("\n")
	}

	if cveInfo.IssueBody != "" {
		sb.WriteString("**Additional Context from Issue**:\n")
		// Truncate if too long
		body := cveInfo.IssueBody
		if len(body) > 2000 {
			body = body[:2000] + "..."
		}
		sb.WriteString(body)
		sb.WriteString("\n\n")
	}

	sb.WriteString("## Dependency Analysis Results\n\n")
	if depResult.CVEAffectsECK {
		sb.WriteString("**Potential matches found in ECK dependencies:**\n\n")

		if len(depResult.DirectMatches) > 0 {
			sb.WriteString("Direct dependencies:\n")
			for _, m := range depResult.DirectMatches {
				sb.WriteString(fmt.Sprintf("- %s@%s (matched: %s)\n", m.Dependency.Path, m.Dependency.Version, m.MatchedPackage))
			}
			sb.WriteString("\n")
		}

		if len(depResult.TransitiveMatches) > 0 {
			sb.WriteString("Transitive (indirect) dependencies:\n")
			for _, m := range depResult.TransitiveMatches {
				sb.WriteString(fmt.Sprintf("- %s@%s (matched: %s)\n", m.Dependency.Path, m.Dependency.Version, m.MatchedPackage))
			}
			sb.WriteString("\n")
		}
	} else {
		sb.WriteString("No matching dependencies found in ECK's go.mod.\n\n")
	}

	// Add govulncheck results - this is critical for accurate analysis
	sb.WriteString("## govulncheck Analysis Results\n\n")
	sb.WriteString(`govulncheck is Go's official vulnerability scanner. Unlike dependency matching, it performs 
static analysis to determine if vulnerable code paths are actually reachable from ECK's code.
This is the most reliable indicator of whether ECK is actually affected.

`)
	if vulnResult != nil {
		if len(vulnResult.CVEMatches) > 0 {
			sb.WriteString("**CRITICAL: govulncheck found that ECK DOES call vulnerable code:**\n\n")
			for _, v := range vulnResult.CVEMatches {
				sb.WriteString(fmt.Sprintf("- Vulnerability: %s", v.ID))
				if len(v.CVEs) > 0 {
					sb.WriteString(fmt.Sprintf(" (%s)", strings.Join(v.CVEs, ", ")))
				}
				sb.WriteString("\n")
				if v.Package != "" {
					sb.WriteString(fmt.Sprintf("  - Affected package: %s\n", v.Package))
				}
				if v.FixedIn != "" {
					sb.WriteString(fmt.Sprintf("  - Fixed in version: %s\n", v.FixedIn))
				}
				if len(v.CalledBy) > 0 {
					sb.WriteString("  - Call path from ECK code: ")
					sb.WriteString(strings.Join(v.CalledBy, " → "))
					sb.WriteString("\n")
				}
				if v.Description != "" {
					sb.WriteString(fmt.Sprintf("  - Description: %s\n", v.Description))
				}
			}
			sb.WriteString("\nThis means ECK's code actually calls the vulnerable functions and IS affected.\n\n")
		} else if len(vulnResult.Vulnerabilities) > 0 {
			sb.WriteString("**govulncheck found other vulnerabilities in ECK (not matching this specific CVE):**\n\n")
			for _, v := range vulnResult.Vulnerabilities {
				sb.WriteString(fmt.Sprintf("- %s", v.ID))
				if len(v.CVEs) > 0 {
					sb.WriteString(fmt.Sprintf(" (%s)", strings.Join(v.CVEs, ", ")))
				}
				if v.Package != "" {
					sb.WriteString(fmt.Sprintf(" in %s", v.Package))
				}
				sb.WriteString("\n")
			}
			sb.WriteString("\nThe specific CVE being analyzed was NOT found by govulncheck, suggesting ECK does not call the vulnerable code paths.\n\n")
		} else {
			sb.WriteString("**govulncheck found NO vulnerabilities affecting ECK.**\n\n")
			sb.WriteString(`This is strong evidence that even though ECK may have the affected dependency, 
ECK's code does NOT call the vulnerable functions. The vulnerability is likely in a part 
of the library that ECK doesn't use.

`)
		}
	} else {
		sb.WriteString("govulncheck was not run. Analysis is based only on dependency matching.\n\n")
	}

	// Add code context if provided
	if codeContext != "" {
		sb.WriteString("## Relevant ECK Source Code\n\n")
		sb.WriteString(`The following ECK source files import or use the affected packages.
IMPORTANT: Carefully analyze this code to determine:
1. How ECK uses the affected library
2. Which specific functions/methods from the vulnerable package are called
3. Whether the vulnerable code paths are actually reachable
4. What data flows through the vulnerable code

`)
		sb.WriteString(codeContext)
		sb.WriteString("\n")
	}

	sb.WriteString(`## Your Analysis Task

You must provide a THOROUGH and DETAILED security analysis. Do not give superficial answers.

Based on ALL the information above (CVE details, dependency analysis, govulncheck results, and source code), provide:

1. **RISK_LEVEL**: HIGH, MEDIUM, LOW, or NONE
   - HIGH: Confirmed vulnerable code paths are reachable, or critical vulnerability in actively used functionality
   - MEDIUM: Dependency matches, vulnerable functionality may be used but not confirmed
   - LOW: Dependency matches but vulnerable code paths appear unreachable
   - NONE: No dependency matches or vulnerability definitively does not apply

2. **SUMMARY**: 2-3 sentences clearly stating whether ECK is affected and why

3. **DETAILED_ANALYSIS**: Provide an IN-DEPTH analysis covering:

   a) **Vulnerability Mechanics**: Explain what the CVE vulnerability does and how it can be exploited
   
   b) **ECK's Usage Pattern**: Based on the source code provided, explain exactly how ECK uses the affected package:
      - Which specific functions/types from the package does ECK call?
      - What is the data flow? Where does input come from and where does output go?
      - Is the usage pattern exposed to untrusted input?
   
   c) **Attack Surface Analysis**: 
      - Could an attacker reach the vulnerable code through ECK's interfaces?
      - What would an attacker need to exploit this in the context of ECK?
      - Consider: Is this code exposed to network traffic? User input? Kubernetes API?
   
   d) **Mitigating Factors**: Are there any factors that reduce the risk?
      - Network policies, authentication requirements, Kubernetes RBAC, etc.
   
   e) **Comparison with govulncheck**: If govulncheck was run, explain what its results mean in context

4. **AFFECTED_AREAS**: List specific files, functions, or components with explanations:
   - File: path/to/file.go - Function: FunctionName - Why: explanation
   - Be specific, reference the actual code you analyzed

5. **EXPLOITATION_SCENARIO**: Describe a concrete attack scenario (or explain why exploitation is unlikely):
   - Step by step, how would an attacker exploit this in ECK's context?
   - What prerequisites would they need?

6. **RECOMMENDATION**: Specific, actionable recommendations:
   - Should ECK upgrade immediately, or can it wait for a regular release cycle?
   - Are there workarounds or mitigations that can be applied?
   - What testing should be done?

7. **CONFIDENCE**: HIGH, MEDIUM, or LOW with justification
   - HIGH: Code was analyzed and vulnerability applicability is clear
   - MEDIUM: Some uncertainty remains
   - LOW: Insufficient information for definitive analysis

FORMAT YOUR RESPONSE EXACTLY AS FOLLOWS (use these exact headers):

RISK_LEVEL: [level]

SUMMARY:
[2-3 sentence summary]

DETAILED_ANALYSIS:
[Your thorough multi-paragraph analysis covering all points above]

AFFECTED_AREAS:
- [Specific file/function with explanation]
- [Another if applicable]
(or "None identified" with explanation)

EXPLOITATION_SCENARIO:
[Concrete attack scenario or explanation of why exploitation is unlikely]

RECOMMENDATION:
[Specific actionable recommendations]

CONFIDENCE: [level] - [brief justification]
`)

	return sb.String()
}

// normalizeHeader strips markdown formatting from a line for header detection
func normalizeHeader(line string) string {
	// Remove common markdown formatting: **, *, #, etc.
	line = strings.ReplaceAll(line, "**", "")
	line = strings.ReplaceAll(line, "*", "")
	line = strings.TrimPrefix(line, "# ")
	line = strings.TrimPrefix(line, "## ")
	line = strings.TrimPrefix(line, "### ")
	line = strings.TrimSpace(line)

	// Remove list markers like "a)", "b)", "i)", "1.", "2.", "-", etc.
	if len(line) >= 2 {
		// Handle letter markers: a), b), ..., i), A), B), etc.
		if (line[0] >= 'a' && line[0] <= 'z' || line[0] >= 'A' && line[0] <= 'Z') && line[1] == ')' {
			line = strings.TrimSpace(line[2:])
		}
		// Handle number markers: 1), 2), 1., 2., etc.
		if line[0] >= '0' && line[0] <= '9' {
			for i := 1; i < len(line); i++ {
				if line[i] == ')' || line[i] == '.' {
					line = strings.TrimSpace(line[i+1:])
					break
				}
				if line[i] < '0' || line[i] > '9' {
					break
				}
			}
		}
	}
	// Handle dash/bullet markers
	line = strings.TrimPrefix(line, "- ")
	line = strings.TrimPrefix(line, "• ")

	return strings.TrimSpace(line)
}

// extractValue extracts the value after a header prefix
func extractValue(line, prefix string) string {
	normalized := normalizeHeader(line)
	if strings.HasPrefix(normalized, prefix) {
		value := strings.TrimPrefix(normalized, prefix)
		return strings.TrimSpace(value)
	}
	return ""
}

// hasHeader checks if a line contains a specific header
func hasHeader(line, prefix string) bool {
	normalized := normalizeHeader(line)
	return strings.HasPrefix(normalized, prefix)
}

// parseAnalysisResponse extracts structured data from the LLM response
func parseAnalysisResponse(response string) *AnalysisResult {
	result := &AnalysisResult{
		RiskLevel:  "UNKNOWN",
		Confidence: "LOW",
	}

	lines := strings.Split(response, "\n")
	var currentSection string
	var sectionContent strings.Builder

	for _, line := range lines {
		line = strings.TrimSpace(line)

		// Check for section headers (handles markdown formatting like **HEADER**:)
		if hasHeader(line, "RISK_LEVEL:") {
			result.RiskLevel = extractValue(line, "RISK_LEVEL:")
			continue
		}
		if hasHeader(line, "CONFIDENCE:") {
			result.Confidence = extractValue(line, "CONFIDENCE:")
			continue
		}
		if hasHeader(line, "SUMMARY:") {
			if currentSection != "" {
				saveSectionContent(result, currentSection, sectionContent.String())
			}
			currentSection = "SUMMARY"
			sectionContent.Reset()
			// Check if there's content on the same line
			content := extractValue(line, "SUMMARY:")
			if content != "" {
				sectionContent.WriteString(content)
			}
			continue
		}
		if hasHeader(line, "DETAILED_ANALYSIS:") {
			if currentSection != "" {
				saveSectionContent(result, currentSection, sectionContent.String())
			}
			currentSection = "DETAILED_ANALYSIS"
			sectionContent.Reset()
			continue
		}
		if hasHeader(line, "AFFECTED_AREAS:") {
			if currentSection != "" {
				saveSectionContent(result, currentSection, sectionContent.String())
			}
			currentSection = "AFFECTED_AREAS"
			sectionContent.Reset()
			continue
		}
		if hasHeader(line, "EXPLOITATION_SCENARIO:") {
			if currentSection != "" {
				saveSectionContent(result, currentSection, sectionContent.String())
			}
			currentSection = "EXPLOITATION_SCENARIO"
			sectionContent.Reset()
			continue
		}
		if hasHeader(line, "RECOMMENDATION:") {
			if currentSection != "" {
				saveSectionContent(result, currentSection, sectionContent.String())
			}
			currentSection = "RECOMMENDATION"
			sectionContent.Reset()
			continue
		}

		// Add content to current section
		if currentSection != "" {
			if sectionContent.Len() > 0 {
				sectionContent.WriteString("\n")
			}
			sectionContent.WriteString(line)
		}
	}

	// Save the last section
	if currentSection != "" {
		saveSectionContent(result, currentSection, sectionContent.String())
	}

	return result
}

// saveSectionContent stores the content in the appropriate field
func saveSectionContent(result *AnalysisResult, section, content string) {
	content = strings.TrimSpace(content)

	switch section {
	case "SUMMARY":
		result.Summary = content
	case "DETAILED_ANALYSIS":
		result.DetailedAnalysis = content
	case "RECOMMENDATION":
		result.Recommendation = content
	case "AFFECTED_AREAS":
		// Parse as list
		lines := strings.Split(content, "\n")
		for _, line := range lines {
			line = strings.TrimSpace(line)
			line = strings.TrimPrefix(line, "-")
			line = strings.TrimPrefix(line, "*")
			line = strings.TrimSpace(line)
			if line != "" && !strings.EqualFold(line, "none identified") && !strings.EqualFold(line, "none") {
				result.AffectedAreas = append(result.AffectedAreas, line)
			}
		}
	case "EXPLOITATION_SCENARIO":
		result.ExploitationScenario = content
	}
}

// AnalyzeWithoutAPI performs a basic analysis when no API key is available
func AnalyzeWithoutAPI(cveInfo *parser.CVEInfo, depResult *deps.CheckResult, vulnResult *vulncheck.Result) *AnalysisResult {
	result := &AnalysisResult{
		Confidence: "LOW",
	}

	// Check govulncheck results first - they're the most reliable
	if vulnResult != nil {
		if len(vulnResult.CVEMatches) > 0 {
			// govulncheck found the CVE - ECK IS affected
			result.RiskLevel = "HIGH"
			result.Confidence = "HIGH"
			result.Summary = fmt.Sprintf("govulncheck confirms %s affects ECK. Vulnerable code paths are reachable from ECK's code.", cveInfo.ID)

			var details strings.Builder
			details.WriteString("govulncheck analysis found that ECK's code calls vulnerable functions:\n\n")
			for _, v := range vulnResult.CVEMatches {
				details.WriteString(fmt.Sprintf("- %s in package %s\n", v.ID, v.Package))
				if v.FixedIn != "" {
					details.WriteString(fmt.Sprintf("  Fixed in: %s\n", v.FixedIn))
				}
				if len(v.CalledBy) > 0 {
					details.WriteString(fmt.Sprintf("  Call path: %s\n", strings.Join(v.CalledBy, " → ")))
					result.AffectedAreas = append(result.AffectedAreas, strings.Join(v.CalledBy, " → "))
				}
			}
			result.DetailedAnalysis = details.String()
			result.Recommendation = "Update the affected dependency to the fixed version immediately. This vulnerability is confirmed to affect ECK."
			return result
		}

		if len(vulnResult.Vulnerabilities) == 0 {
			// govulncheck found NO vulnerabilities - even if deps match, ECK is likely safe
			if depResult.CVEAffectsECK {
				result.RiskLevel = "LOW"
				result.Confidence = "HIGH"
				result.Summary = fmt.Sprintf("Although %s affects an ECK dependency, govulncheck confirms ECK does NOT call the vulnerable code.", cveInfo.ID)
				result.DetailedAnalysis = "govulncheck performs static analysis to trace code paths. It found no path from ECK's code to the vulnerable functions. This means ECK uses different parts of the library that are not affected by this CVE."
				result.Recommendation = "No immediate action required. The dependency can be updated in a regular release cycle. Monitor for any scope changes to the CVE."
				return result
			}
		}
	}

	// Fall back to dependency-only analysis
	if !depResult.CVEAffectsECK {
		result.RiskLevel = "NONE"
		result.Summary = fmt.Sprintf("Based on dependency analysis, %s does not appear to affect any ECK dependencies.", cveInfo.ID)
		result.DetailedAnalysis = "No matching packages were found in ECK's go.mod file. However, this analysis is based solely on package name matching and may not capture all potential impacts."
		result.Recommendation = "No immediate action required. Monitor for updates if the CVE scope expands."
	} else {
		// Determine risk based on direct vs transitive matches
		if len(depResult.DirectMatches) > 0 {
			result.RiskLevel = "MEDIUM"
			result.Summary = fmt.Sprintf("%s may affect ECK through direct dependencies. Manual review recommended.", cveInfo.ID)

			var affectedDeps []string
			for _, m := range depResult.DirectMatches {
				affectedDeps = append(affectedDeps, m.Dependency.Path)
				result.AffectedAreas = append(result.AffectedAreas, fmt.Sprintf("Direct dependency: %s", m.Dependency.Path))
			}
			result.DetailedAnalysis = fmt.Sprintf("The following direct dependencies may be affected: %s. A detailed code review is needed to determine if ECK uses the vulnerable functionality.", strings.Join(affectedDeps, ", "))
			result.Recommendation = "Review the affected dependencies and assess whether ECK uses the vulnerable code paths. Consider updating to patched versions if available."
		} else {
			result.RiskLevel = "LOW"
			result.Summary = fmt.Sprintf("%s may affect ECK through transitive dependencies. Lower risk but should be monitored.", cveInfo.ID)

			var affectedDeps []string
			for _, m := range depResult.TransitiveMatches {
				affectedDeps = append(affectedDeps, m.Dependency.Path)
				result.AffectedAreas = append(result.AffectedAreas, fmt.Sprintf("Transitive dependency: %s", m.Dependency.Path))
			}
			result.DetailedAnalysis = fmt.Sprintf("The following transitive dependencies may be affected: %s. These are indirect dependencies and may have limited exposure.", strings.Join(affectedDeps, ", "))
			result.Recommendation = "Monitor for updates to direct dependencies that may include fixes for this transitive vulnerability."
		}
	}

	return result
}
