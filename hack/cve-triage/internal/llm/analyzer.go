// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License 2.0;
// you may not use this file except in compliance with the Elastic License 2.0.

package llm

import (
	"context"
	"fmt"
	"strings"

	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/deps"
	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/parser"
	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/vulncheck"
	"github.com/google/generative-ai-go/genai"
	"google.golang.org/api/option"
)

// AnalysisResult contains the LLM's analysis of the CVE
type AnalysisResult struct {
	RiskLevel        string   `json:"riskLevel"`        // HIGH, MEDIUM, LOW, NONE
	Summary          string   `json:"summary"`          // Brief summary
	DetailedAnalysis string   `json:"detailedAnalysis"` // Full analysis
	Recommendation   string   `json:"recommendation"`   // Suggested action
	Confidence       string   `json:"confidence"`       // HIGH, MEDIUM, LOW
	AffectedAreas    []string `json:"affectedAreas"`    // Parts of ECK that might be affected
}

// Analyzer uses Gemini to analyze CVE impact on ECK
type Analyzer struct {
	client    *genai.Client
	model     *genai.GenerativeModel
	modelName string
}

// Ensure Analyzer implements Provider interface
var _ Provider = (*Analyzer)(nil)

// DefaultModel is the default Gemini model to use
// See available models: https://ai.google.dev/models/gemini
// Current options (Dec 2024): gemini-2.0-flash-lite, gemini-2.5-flash, gemini-2.5-pro
const DefaultModel = "gemini-2.0-flash-lite"

// NewAnalyzer creates a new LLM analyzer with Gemini
func NewAnalyzer(ctx context.Context, apiKey string) (*Analyzer, error) {
	return NewAnalyzerWithModel(ctx, apiKey, DefaultModel)
}

// NewAnalyzerWithModel creates a new LLM analyzer with a specific model
func NewAnalyzerWithModel(ctx context.Context, apiKey, modelName string) (*Analyzer, error) {
	client, err := genai.NewClient(ctx, option.WithAPIKey(apiKey))
	if err != nil {
		return nil, fmt.Errorf("failed to create Gemini client: %w", err)
	}

	if modelName == "" {
		modelName = DefaultModel
	}

	model := client.GenerativeModel(modelName)
	model.SetTemperature(0.2) // Low temperature for more deterministic responses
	model.SetTopP(0.8)

	return &Analyzer{
		client:    client,
		model:     model,
		modelName: modelName,
	}, nil
}

// Name returns the provider name
func (a *Analyzer) Name() string {
	return fmt.Sprintf("Gemini (%s)", a.modelName)
}

// IsAvailable checks if Gemini is available (always true if client was created)
func (a *Analyzer) IsAvailable(ctx context.Context) bool {
	return a.client != nil && a.model != nil
}

// Close releases the Gemini client resources
func (a *Analyzer) Close() error {
	return a.client.Close()
}

// Analyze performs LLM-based analysis of the CVE's impact on ECK
func (a *Analyzer) Analyze(ctx context.Context, cveInfo *parser.CVEInfo, depResult *deps.CheckResult, vulnResult *vulncheck.Result) (*AnalysisResult, error) {
	prompt := buildAnalysisPrompt(cveInfo, depResult, vulnResult)
	return a.analyzeWithPrompt(ctx, prompt)
}

// analyzeWithPrompt performs analysis with a custom prompt (used by RAG)
func (a *Analyzer) analyzeWithPrompt(ctx context.Context, prompt string) (*AnalysisResult, error) {
	resp, err := a.model.GenerateContent(ctx, genai.Text(prompt))
	if err != nil {
		return nil, fmt.Errorf("failed to generate analysis: %w", err)
	}

	if len(resp.Candidates) == 0 || len(resp.Candidates[0].Content.Parts) == 0 {
		return nil, fmt.Errorf("no response from Gemini")
	}

	// Extract text from response
	var responseText string
	for _, part := range resp.Candidates[0].Content.Parts {
		if text, ok := part.(genai.Text); ok {
			responseText += string(text)
		}
	}

	return parseAnalysisResponse(responseText), nil
}

// buildAnalysisPrompt creates the prompt for CVE analysis
func buildAnalysisPrompt(cveInfo *parser.CVEInfo, depResult *deps.CheckResult, vulnResult *vulncheck.Result) string {
	var sb strings.Builder

	sb.WriteString(`You are a security analyst specializing in Kubernetes operators and Go applications. 
Analyze the following CVE and determine its impact on ECK (Elastic Cloud on Kubernetes).

ECK is a Kubernetes operator that manages Elasticsearch, Kibana, APM Server, Enterprise Search, 
Beats, Elastic Agent, Elastic Maps Server, and Logstash deployments on Kubernetes.

`)

	sb.WriteString("## CVE Information\n\n")
	sb.WriteString(fmt.Sprintf("**CVE ID**: %s\n", cveInfo.ID))
	sb.WriteString(fmt.Sprintf("**Severity**: %s (CVSS: %.1f)\n", cveInfo.Severity, cveInfo.CVSSScore))
	sb.WriteString(fmt.Sprintf("**Description**: %s\n\n", cveInfo.Description))

	if len(cveInfo.AffectedPackages) > 0 {
		sb.WriteString("**Affected Packages** (from NVD):\n")
		for _, pkg := range cveInfo.AffectedPackages {
			sb.WriteString(fmt.Sprintf("- %s\n", pkg))
		}
		sb.WriteString("\n")
	}

	if cveInfo.IssueBody != "" {
		sb.WriteString("**Additional Context from Issue**:\n")
		// Truncate if too long
		body := cveInfo.IssueBody
		if len(body) > 2000 {
			body = body[:2000] + "..."
		}
		sb.WriteString(body)
		sb.WriteString("\n\n")
	}

	sb.WriteString("## Dependency Analysis Results\n\n")
	if depResult.CVEAffectsECK {
		sb.WriteString("**Potential matches found in ECK dependencies:**\n\n")

		if len(depResult.DirectMatches) > 0 {
			sb.WriteString("Direct dependencies:\n")
			for _, m := range depResult.DirectMatches {
				sb.WriteString(fmt.Sprintf("- %s@%s (matched: %s)\n", m.Dependency.Path, m.Dependency.Version, m.MatchedPackage))
			}
			sb.WriteString("\n")
		}

		if len(depResult.TransitiveMatches) > 0 {
			sb.WriteString("Transitive (indirect) dependencies:\n")
			for _, m := range depResult.TransitiveMatches {
				sb.WriteString(fmt.Sprintf("- %s@%s (matched: %s)\n", m.Dependency.Path, m.Dependency.Version, m.MatchedPackage))
			}
			sb.WriteString("\n")
		}
	} else {
		sb.WriteString("No matching dependencies found in ECK's go.mod.\n\n")
	}

	// Add govulncheck results - this is critical for accurate analysis
	sb.WriteString("## govulncheck Analysis Results\n\n")
	sb.WriteString(`govulncheck is Go's official vulnerability scanner. Unlike dependency matching, it performs 
static analysis to determine if vulnerable code paths are actually reachable from ECK's code.
This is the most reliable indicator of whether ECK is actually affected.

`)
	if vulnResult != nil {
		if len(vulnResult.CVEMatches) > 0 {
			sb.WriteString("**CRITICAL: govulncheck found that ECK DOES call vulnerable code:**\n\n")
			for _, v := range vulnResult.CVEMatches {
				sb.WriteString(fmt.Sprintf("- Vulnerability: %s", v.ID))
				if len(v.CVEs) > 0 {
					sb.WriteString(fmt.Sprintf(" (%s)", strings.Join(v.CVEs, ", ")))
				}
				sb.WriteString("\n")
				if v.Package != "" {
					sb.WriteString(fmt.Sprintf("  - Affected package: %s\n", v.Package))
				}
				if v.FixedIn != "" {
					sb.WriteString(fmt.Sprintf("  - Fixed in version: %s\n", v.FixedIn))
				}
				if len(v.CalledBy) > 0 {
					sb.WriteString("  - Call path from ECK code: ")
					sb.WriteString(strings.Join(v.CalledBy, " → "))
					sb.WriteString("\n")
				}
				if v.Description != "" {
					sb.WriteString(fmt.Sprintf("  - Description: %s\n", v.Description))
				}
			}
			sb.WriteString("\nThis means ECK's code actually calls the vulnerable functions and IS affected.\n\n")
		} else if len(vulnResult.Vulnerabilities) > 0 {
			sb.WriteString("**govulncheck found other vulnerabilities in ECK (not matching this specific CVE):**\n\n")
			for _, v := range vulnResult.Vulnerabilities {
				sb.WriteString(fmt.Sprintf("- %s", v.ID))
				if len(v.CVEs) > 0 {
					sb.WriteString(fmt.Sprintf(" (%s)", strings.Join(v.CVEs, ", ")))
				}
				if v.Package != "" {
					sb.WriteString(fmt.Sprintf(" in %s", v.Package))
				}
				sb.WriteString("\n")
			}
			sb.WriteString("\nThe specific CVE being analyzed was NOT found by govulncheck, suggesting ECK does not call the vulnerable code paths.\n\n")
		} else {
			sb.WriteString("**govulncheck found NO vulnerabilities affecting ECK.**\n\n")
			sb.WriteString(`This is strong evidence that even though ECK may have the affected dependency, 
ECK's code does NOT call the vulnerable functions. The vulnerability is likely in a part 
of the library that ECK doesn't use.

`)
		}
	} else {
		sb.WriteString("govulncheck was not run. Analysis is based only on dependency matching.\n\n")
	}

	sb.WriteString(`## Your Analysis Task

Based on the CVE information, dependency analysis, and govulncheck results above, provide:

1. **RISK LEVEL**: Assess the risk to ECK as one of: HIGH, MEDIUM, LOW, or NONE
   - HIGH: govulncheck confirms ECK calls vulnerable code, OR critical vulnerability in actively used dependency
   - MEDIUM: Dependency matches but govulncheck didn't run or results unclear
   - LOW: Dependency matches but govulncheck confirms ECK doesn't call vulnerable code
   - NONE: No dependency matches, OR govulncheck confirms no vulnerability

2. **SUMMARY**: A 2-3 sentence summary of whether and how this CVE affects ECK

3. **DETAILED ANALYSIS**: Explain your reasoning, considering:
   - The govulncheck results (most important - does ECK actually call the vulnerable code?)
   - Whether ECK uses the affected functionality based on the call paths shown
   - Attack vectors and whether they apply to ECK's usage patterns
   - The nature of ECK (Kubernetes operator) and its security context

4. **AFFECTED AREAS**: List specific ECK components or code areas that might be affected (if any)
   - If govulncheck showed call paths, reference those specific code paths

5. **RECOMMENDATION**: What action should the ECK team take?

6. **CONFIDENCE**: Rate your confidence in this analysis as HIGH, MEDIUM, or LOW
   - If govulncheck was run, confidence should generally be HIGH
   - If only dependency matching was done, confidence should be MEDIUM or LOW

Format your response as follows:

RISK_LEVEL: [HIGH|MEDIUM|LOW|NONE]

SUMMARY:
[Your 2-3 sentence summary]

DETAILED_ANALYSIS:
[Your detailed analysis]

AFFECTED_AREAS:
- [Area 1]
- [Area 2]
(or "None identified" if no areas are affected)

RECOMMENDATION:
[Your recommendation]

CONFIDENCE: [HIGH|MEDIUM|LOW]
`)

	return sb.String()
}

// parseAnalysisResponse extracts structured data from the LLM response
func parseAnalysisResponse(response string) *AnalysisResult {
	result := &AnalysisResult{
		RiskLevel:  "UNKNOWN",
		Confidence: "LOW",
	}

	lines := strings.Split(response, "\n")
	var currentSection string
	var sectionContent strings.Builder

	for _, line := range lines {
		line = strings.TrimSpace(line)

		// Check for section headers
		if strings.HasPrefix(line, "RISK_LEVEL:") {
			result.RiskLevel = strings.TrimSpace(strings.TrimPrefix(line, "RISK_LEVEL:"))
			continue
		}
		if strings.HasPrefix(line, "CONFIDENCE:") {
			result.Confidence = strings.TrimSpace(strings.TrimPrefix(line, "CONFIDENCE:"))
			continue
		}
		if strings.HasPrefix(line, "SUMMARY:") {
			if currentSection != "" {
				saveSectionContent(result, currentSection, sectionContent.String())
			}
			currentSection = "SUMMARY"
			sectionContent.Reset()
			// Check if there's content on the same line
			content := strings.TrimSpace(strings.TrimPrefix(line, "SUMMARY:"))
			if content != "" {
				sectionContent.WriteString(content)
			}
			continue
		}
		if strings.HasPrefix(line, "DETAILED_ANALYSIS:") {
			if currentSection != "" {
				saveSectionContent(result, currentSection, sectionContent.String())
			}
			currentSection = "DETAILED_ANALYSIS"
			sectionContent.Reset()
			continue
		}
		if strings.HasPrefix(line, "AFFECTED_AREAS:") {
			if currentSection != "" {
				saveSectionContent(result, currentSection, sectionContent.String())
			}
			currentSection = "AFFECTED_AREAS"
			sectionContent.Reset()
			continue
		}
		if strings.HasPrefix(line, "RECOMMENDATION:") {
			if currentSection != "" {
				saveSectionContent(result, currentSection, sectionContent.String())
			}
			currentSection = "RECOMMENDATION"
			sectionContent.Reset()
			continue
		}

		// Add content to current section
		if currentSection != "" {
			if sectionContent.Len() > 0 {
				sectionContent.WriteString("\n")
			}
			sectionContent.WriteString(line)
		}
	}

	// Save the last section
	if currentSection != "" {
		saveSectionContent(result, currentSection, sectionContent.String())
	}

	return result
}

// saveSectionContent stores the content in the appropriate field
func saveSectionContent(result *AnalysisResult, section, content string) {
	content = strings.TrimSpace(content)

	switch section {
	case "SUMMARY":
		result.Summary = content
	case "DETAILED_ANALYSIS":
		result.DetailedAnalysis = content
	case "RECOMMENDATION":
		result.Recommendation = content
	case "AFFECTED_AREAS":
		// Parse as list
		lines := strings.Split(content, "\n")
		for _, line := range lines {
			line = strings.TrimSpace(line)
			line = strings.TrimPrefix(line, "-")
			line = strings.TrimPrefix(line, "*")
			line = strings.TrimSpace(line)
			if line != "" && !strings.EqualFold(line, "none identified") && !strings.EqualFold(line, "none") {
				result.AffectedAreas = append(result.AffectedAreas, line)
			}
		}
	}
}

// AnalyzeWithoutAPI performs a basic analysis when no API key is available
func AnalyzeWithoutAPI(cveInfo *parser.CVEInfo, depResult *deps.CheckResult, vulnResult *vulncheck.Result) *AnalysisResult {
	result := &AnalysisResult{
		Confidence: "LOW",
	}

	// Check govulncheck results first - they're the most reliable
	if vulnResult != nil {
		if len(vulnResult.CVEMatches) > 0 {
			// govulncheck found the CVE - ECK IS affected
			result.RiskLevel = "HIGH"
			result.Confidence = "HIGH"
			result.Summary = fmt.Sprintf("govulncheck confirms %s affects ECK. Vulnerable code paths are reachable from ECK's code.", cveInfo.ID)

			var details strings.Builder
			details.WriteString("govulncheck analysis found that ECK's code calls vulnerable functions:\n\n")
			for _, v := range vulnResult.CVEMatches {
				details.WriteString(fmt.Sprintf("- %s in package %s\n", v.ID, v.Package))
				if v.FixedIn != "" {
					details.WriteString(fmt.Sprintf("  Fixed in: %s\n", v.FixedIn))
				}
				if len(v.CalledBy) > 0 {
					details.WriteString(fmt.Sprintf("  Call path: %s\n", strings.Join(v.CalledBy, " → ")))
					result.AffectedAreas = append(result.AffectedAreas, strings.Join(v.CalledBy, " → "))
				}
			}
			result.DetailedAnalysis = details.String()
			result.Recommendation = "Update the affected dependency to the fixed version immediately. This vulnerability is confirmed to affect ECK."
			return result
		}

		if len(vulnResult.Vulnerabilities) == 0 {
			// govulncheck found NO vulnerabilities - even if deps match, ECK is likely safe
			if depResult.CVEAffectsECK {
				result.RiskLevel = "LOW"
				result.Confidence = "HIGH"
				result.Summary = fmt.Sprintf("Although %s affects an ECK dependency, govulncheck confirms ECK does NOT call the vulnerable code.", cveInfo.ID)
				result.DetailedAnalysis = "govulncheck performs static analysis to trace code paths. It found no path from ECK's code to the vulnerable functions. This means ECK uses different parts of the library that are not affected by this CVE."
				result.Recommendation = "No immediate action required. The dependency can be updated in a regular release cycle. Monitor for any scope changes to the CVE."
				return result
			}
		}
	}

	// Fall back to dependency-only analysis
	if !depResult.CVEAffectsECK {
		result.RiskLevel = "NONE"
		result.Summary = fmt.Sprintf("Based on dependency analysis, %s does not appear to affect any ECK dependencies.", cveInfo.ID)
		result.DetailedAnalysis = "No matching packages were found in ECK's go.mod file. However, this analysis is based solely on package name matching and may not capture all potential impacts."
		result.Recommendation = "No immediate action required. Monitor for updates if the CVE scope expands."
	} else {
		// Determine risk based on direct vs transitive matches
		if len(depResult.DirectMatches) > 0 {
			result.RiskLevel = "MEDIUM"
			result.Summary = fmt.Sprintf("%s may affect ECK through direct dependencies. Manual review recommended.", cveInfo.ID)

			var affectedDeps []string
			for _, m := range depResult.DirectMatches {
				affectedDeps = append(affectedDeps, m.Dependency.Path)
				result.AffectedAreas = append(result.AffectedAreas, fmt.Sprintf("Direct dependency: %s", m.Dependency.Path))
			}
			result.DetailedAnalysis = fmt.Sprintf("The following direct dependencies may be affected: %s. A detailed code review is needed to determine if ECK uses the vulnerable functionality.", strings.Join(affectedDeps, ", "))
			result.Recommendation = "Review the affected dependencies and assess whether ECK uses the vulnerable code paths. Consider updating to patched versions if available."
		} else {
			result.RiskLevel = "LOW"
			result.Summary = fmt.Sprintf("%s may affect ECK through transitive dependencies. Lower risk but should be monitored.", cveInfo.ID)

			var affectedDeps []string
			for _, m := range depResult.TransitiveMatches {
				affectedDeps = append(affectedDeps, m.Dependency.Path)
				result.AffectedAreas = append(result.AffectedAreas, fmt.Sprintf("Transitive dependency: %s", m.Dependency.Path))
			}
			result.DetailedAnalysis = fmt.Sprintf("The following transitive dependencies may be affected: %s. These are indirect dependencies and may have limited exposure.", strings.Join(affectedDeps, ", "))
			result.Recommendation = "Monitor for updates to direct dependencies that may include fixes for this transitive vulnerability."
		}
	}

	return result
}
