// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License 2.0;
// you may not use this file except in compliance with the Elastic License 2.0.

package llm

import (
	"context"
	"fmt"

	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/deps"
	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/parser"
	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/vulncheck"
)

// ProviderType represents the type of LLM provider
type ProviderType string

const (
	ProviderGemini  ProviderType = "gemini"
	ProviderOllama  ProviderType = "ollama"
	ProviderNone    ProviderType = "none"
	// Future providers:
	// ProviderOpenAI  ProviderType = "openai"
	// ProviderClaude  ProviderType = "claude"
	// ProviderGroq    ProviderType = "groq"
)

// Provider is the interface that all LLM providers must implement
type Provider interface {
	// Name returns the provider name for display
	Name() string

	// Analyze performs CVE analysis using the LLM
	Analyze(ctx context.Context, cveInfo *parser.CVEInfo, depResult *deps.CheckResult, vulnResult *vulncheck.Result) (*AnalysisResult, error)

	// AnalyzeWithCode performs CVE analysis with source code context
	AnalyzeWithCode(ctx context.Context, cveInfo *parser.CVEInfo, depResult *deps.CheckResult, vulnResult *vulncheck.Result, codeContext string) (*AnalysisResult, error)

	// IsAvailable checks if the provider is ready to use
	IsAvailable(ctx context.Context) bool

	// Close releases any resources held by the provider
	Close() error
}

// Config holds configuration for creating an LLM provider
type Config struct {
	// Provider type
	Provider ProviderType

	// Gemini settings
	GeminiAPIKey string
	GeminiModel  string

	// Ollama settings
	OllamaURL   string
	OllamaModel string

	// Debug settings
	Verbose bool

	// Future: OpenAI settings
	// OpenAIAPIKey string
	// OpenAIModel  string

	// Future: Claude settings
	// ClaudeAPIKey string
	// ClaudeModel  string
}

// NewProvider creates an LLM provider based on configuration
func NewProvider(ctx context.Context, cfg Config) (Provider, error) {
	switch cfg.Provider {
	case ProviderGemini:
		if cfg.GeminiAPIKey == "" {
			return nil, fmt.Errorf("gemini API key is required")
		}
		model := cfg.GeminiModel
		if model == "" {
			model = DefaultModel
		}
		analyzer, err := NewAnalyzerWithModel(ctx, cfg.GeminiAPIKey, model)
		if err != nil {
			return nil, err
		}
		analyzer.verbose = cfg.Verbose
		return analyzer, nil

	case ProviderOllama:
		url := cfg.OllamaURL
		if url == "" {
			url = DefaultOllamaURL
		}
		model := cfg.OllamaModel
		if model == "" {
			model = DefaultOllamaModel
		}
		analyzer := NewOllamaAnalyzer(url, model)
		analyzer.verbose = cfg.Verbose
		return analyzer, nil

	case ProviderNone:
		return &NoOpProvider{}, nil

	default:
		return nil, fmt.Errorf("unknown provider type: %s", cfg.Provider)
	}
}

// DetectProvider automatically detects which provider to use based on available config
func DetectProvider(cfg Config) ProviderType {
	// Priority: explicit provider > Ollama (if available) > Gemini (if key) > None
	if cfg.Provider != "" {
		return cfg.Provider
	}

	// If Gemini API key is set, use Gemini
	if cfg.GeminiAPIKey != "" {
		return ProviderGemini
	}

	// Default to none (basic analysis)
	return ProviderNone
}

// AvailableProviders returns a list of available provider types
func AvailableProviders() []ProviderType {
	return []ProviderType{
		ProviderGemini,
		ProviderOllama,
		ProviderNone,
	}
}

// NoOpProvider is a provider that performs basic analysis without an LLM
type NoOpProvider struct{}

func (n *NoOpProvider) Name() string {
	return "basic (no LLM)"
}

func (n *NoOpProvider) Analyze(ctx context.Context, cveInfo *parser.CVEInfo, depResult *deps.CheckResult, vulnResult *vulncheck.Result) (*AnalysisResult, error) {
	return AnalyzeWithoutAPI(cveInfo, depResult, vulnResult), nil
}

func (n *NoOpProvider) AnalyzeWithCode(ctx context.Context, cveInfo *parser.CVEInfo, depResult *deps.CheckResult, vulnResult *vulncheck.Result, codeContext string) (*AnalysisResult, error) {
	// NoOp provider ignores code context
	return AnalyzeWithoutAPI(cveInfo, depResult, vulnResult), nil
}

func (n *NoOpProvider) IsAvailable(ctx context.Context) bool {
	return true
}

func (n *NoOpProvider) Close() error {
	return nil
}

