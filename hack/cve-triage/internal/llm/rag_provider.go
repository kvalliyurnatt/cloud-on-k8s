// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License 2.0;
// you may not use this file except in compliance with the Elastic License 2.0.

package llm

import (
	"context"
	"fmt"
	"strings"

	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/deps"
	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/parser"
	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/rag"
	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/vulncheck"
)

// RAGProvider wraps any LLM provider with RAG capabilities
type RAGProvider struct {
	llm         Provider
	ragProvider rag.Provider
	topK        int
}

// Ensure RAGProvider implements Provider interface
var _ Provider = (*RAGProvider)(nil)

// NewRAGProvider creates a RAG-enhanced LLM provider
func NewRAGProvider(llm Provider, ragProvider rag.Provider, topK int) *RAGProvider {
	if topK == 0 {
		topK = 5
	}
	return &RAGProvider{
		llm:         llm,
		ragProvider: ragProvider,
		topK:        topK,
	}
}

// Name returns the provider name
func (r *RAGProvider) Name() string {
	return fmt.Sprintf("%s + RAG (%d chunks)", r.llm.Name(), r.ragProvider.IndexSize())
}

// IsAvailable checks if the provider is ready
func (r *RAGProvider) IsAvailable(ctx context.Context) bool {
	return r.llm.IsAvailable(ctx) && r.ragProvider.IsReady(ctx)
}

// Close releases resources
func (r *RAGProvider) Close() error {
	if err := r.ragProvider.Close(); err != nil {
		return err
	}
	return r.llm.Close()
}

// AnalyzeWithCode performs RAG-enhanced analysis with additional code context
// The code context is merged with RAG-retrieved chunks
func (r *RAGProvider) AnalyzeWithCode(
	ctx context.Context,
	cveInfo *parser.CVEInfo,
	depResult *deps.CheckResult,
	vulnResult *vulncheck.Result,
	codeContext string,
) (*AnalysisResult, error) {
	// For RAG provider, we combine the provided code context with RAG retrieval
	// The provided codeContext takes precedence as it's more targeted
	return r.llm.AnalyzeWithCode(ctx, cveInfo, depResult, vulnResult, codeContext)
}

// Analyze performs RAG-enhanced CVE analysis
func (r *RAGProvider) Analyze(
	ctx context.Context,
	cveInfo *parser.CVEInfo,
	depResult *deps.CheckResult,
	vulnResult *vulncheck.Result,
) (*AnalysisResult, error) {
	// Build query from CVE info
	query := buildRAGQuery(cveInfo, depResult, vulnResult)

	// Retrieve relevant code chunks
	codeChunks, err := r.ragProvider.Retrieve(ctx, query, r.topK)
	if err != nil {
		// Fall back to non-RAG analysis if retrieval fails
		fmt.Printf("   ⚠️  RAG retrieval failed: %v, falling back to standard analysis\n", err)
		return r.llm.Analyze(ctx, cveInfo, depResult, vulnResult)
	}

	if len(codeChunks) == 0 {
		// No relevant chunks found, use standard analysis
		return r.llm.Analyze(ctx, cveInfo, depResult, vulnResult)
	}

	// For providers that support custom prompts, we'd inject the code context
	// For now, we'll use the standard analysis but could extend this
	// to support prompt augmentation for different providers
	
	// Augment the analysis with code context
	result, err := r.analyzeWithContext(ctx, cveInfo, depResult, vulnResult, codeChunks)
	if err != nil {
		return nil, err
	}

	return result, nil
}

// buildRAGQuery builds a search query from CVE information
func buildRAGQuery(cveInfo *parser.CVEInfo, depResult *deps.CheckResult, vulnResult *vulncheck.Result) string {
	var parts []string

	// Add CVE ID
	if cveInfo.ID != "" {
		parts = append(parts, cveInfo.ID)
	}

	// Add CVE description
	if cveInfo.Description != "" {
		parts = append(parts, cveInfo.Description)
	}

	// Add issue body as fallback context
	if cveInfo.IssueBody != "" {
		// Truncate if too long
		body := cveInfo.IssueBody
		if len(body) > 500 {
			body = body[:500]
		}
		parts = append(parts, body)
	}

	// Add affected packages
	for _, pkg := range cveInfo.AffectedPackages {
		parts = append(parts, pkg)
	}

	// Add matched dependencies
	for _, m := range depResult.DirectMatches {
		parts = append(parts, m.Dependency.Path)
	}
	for _, m := range depResult.TransitiveMatches {
		parts = append(parts, m.Dependency.Path)
	}

	// Add vulncheck call paths
	if vulnResult != nil {
		for _, v := range vulnResult.CVEMatches {
			parts = append(parts, v.Package)
			parts = append(parts, v.CalledBy...)
		}
	}

	// Fallback: if still empty, use generic terms from the CVE
	if len(parts) == 0 {
		parts = append(parts, "vulnerability security")
	}

	return strings.Join(parts, " ")
}

// analyzeWithContext performs analysis with retrieved code context
func (r *RAGProvider) analyzeWithContext(
	ctx context.Context,
	cveInfo *parser.CVEInfo,
	depResult *deps.CheckResult,
	vulnResult *vulncheck.Result,
	codeChunks []rag.SearchResult,
) (*AnalysisResult, error) {
	// For Ollama, we can modify the prompt directly
	if ollamaProvider, ok := r.llm.(*OllamaAnalyzer); ok {
		return r.analyzeWithOllama(ctx, ollamaProvider, cveInfo, depResult, vulnResult, codeChunks)
	}

	// For Gemini, we can also modify the prompt
	if geminiProvider, ok := r.llm.(*Analyzer); ok {
		return r.analyzeWithGemini(ctx, geminiProvider, cveInfo, depResult, vulnResult, codeChunks)
	}

	// For other providers, fall back to standard analysis
	// (they might not support custom prompts)
	return r.llm.Analyze(ctx, cveInfo, depResult, vulnResult)
}

// analyzeWithOllama performs RAG-enhanced analysis with Ollama
func (r *RAGProvider) analyzeWithOllama(
	ctx context.Context,
	ollama *OllamaAnalyzer,
	cveInfo *parser.CVEInfo,
	depResult *deps.CheckResult,
	vulnResult *vulncheck.Result,
	codeChunks []rag.SearchResult,
) (*AnalysisResult, error) {
	prompt := r.buildRAGPrompt(cveInfo, depResult, vulnResult, codeChunks)
	return ollama.analyzeWithPrompt(ctx, prompt)
}

// analyzeWithGemini performs RAG-enhanced analysis with Gemini
func (r *RAGProvider) analyzeWithGemini(
	ctx context.Context,
	gemini *Analyzer,
	cveInfo *parser.CVEInfo,
	depResult *deps.CheckResult,
	vulnResult *vulncheck.Result,
	codeChunks []rag.SearchResult,
) (*AnalysisResult, error) {
	prompt := r.buildRAGPrompt(cveInfo, depResult, vulnResult, codeChunks)
	return gemini.analyzeWithPrompt(ctx, prompt)
}

// buildRAGPrompt builds a prompt with retrieved code context
func (r *RAGProvider) buildRAGPrompt(
	cveInfo *parser.CVEInfo,
	depResult *deps.CheckResult,
	vulnResult *vulncheck.Result,
	codeChunks []rag.SearchResult,
) string {
	var sb strings.Builder

	sb.WriteString(`You are a security analyst specializing in Kubernetes operators and Go applications.
Analyze the following CVE and determine its impact on ECK (Elastic Cloud on Kubernetes).

ECK is a Kubernetes operator that manages Elasticsearch, Kibana, APM Server, Enterprise Search,
Beats, Elastic Agent, Elastic Maps Server, and Logstash deployments on Kubernetes.

`)

	// Add retrieved code context
	if len(codeChunks) > 0 {
		sb.WriteString("## Relevant ECK Code (Retrieved via RAG)\n\n")
		sb.WriteString("The following code sections from ECK are most relevant to this CVE based on semantic similarity:\n\n")

		for i, result := range codeChunks {
			if i >= 5 { // Limit to top 5 chunks
				break
			}
			sb.WriteString(fmt.Sprintf("### %d. %s (similarity: %.2f)\n",
				i+1, result.Chunk.Name, result.Score))
			sb.WriteString(fmt.Sprintf("File: `%s:%d-%d`\n",
				result.Chunk.FilePath,
				result.Chunk.StartLine,
				result.Chunk.EndLine))
			sb.WriteString(fmt.Sprintf("Package: `%s`, Type: %s\n",
				result.Chunk.Package,
				result.Chunk.Type))
			sb.WriteString("```go\n")
			// Truncate very long chunks
			content := result.Chunk.Content
			if len(content) > 1500 {
				content = content[:1500] + "\n// ... truncated"
			}
			sb.WriteString(content)
			sb.WriteString("\n```\n\n")
		}
	}

	// Add CVE info
	sb.WriteString("## CVE Information\n\n")
	sb.WriteString(fmt.Sprintf("**CVE ID**: %s\n", cveInfo.ID))
	sb.WriteString(fmt.Sprintf("**Severity**: %s (CVSS: %.1f)\n", cveInfo.Severity, cveInfo.CVSSScore))
	sb.WriteString(fmt.Sprintf("**Description**: %s\n\n", cveInfo.Description))

	if len(cveInfo.AffectedPackages) > 0 {
		sb.WriteString("**Affected Packages**:\n")
		for _, pkg := range cveInfo.AffectedPackages {
			sb.WriteString(fmt.Sprintf("- %s\n", pkg))
		}
		sb.WriteString("\n")
	}

	// Add dependency analysis
	sb.WriteString("## Dependency Analysis\n\n")
	if depResult.CVEAffectsECK {
		sb.WriteString("**Matches found:**\n")
		for _, m := range depResult.DirectMatches {
			sb.WriteString(fmt.Sprintf("- Direct: %s@%s\n", m.Dependency.Path, m.Dependency.Version))
		}
		for _, m := range depResult.TransitiveMatches {
			sb.WriteString(fmt.Sprintf("- Transitive: %s@%s\n", m.Dependency.Path, m.Dependency.Version))
		}
	} else {
		sb.WriteString("No matching dependencies found.\n")
	}
	sb.WriteString("\n")

	// Add govulncheck results
	sb.WriteString("## govulncheck Results\n\n")
	if vulnResult != nil && len(vulnResult.CVEMatches) > 0 {
		sb.WriteString("**CRITICAL: Vulnerable code paths confirmed:**\n")
		for _, v := range vulnResult.CVEMatches {
			sb.WriteString(fmt.Sprintf("- %s in %s\n", v.ID, v.Package))
			if len(v.CalledBy) > 0 {
				sb.WriteString(fmt.Sprintf("  Call path: %s\n", strings.Join(v.CalledBy, " → ")))
			}
		}
	} else if vulnResult != nil {
		sb.WriteString("No vulnerable code paths found by govulncheck.\n")
	} else {
		sb.WriteString("govulncheck not run.\n")
	}
	sb.WriteString("\n")

	// Analysis task
	sb.WriteString(`## Your Analysis Task

Based on the CVE information, the retrieved ECK code, dependency analysis, and govulncheck results, provide:

1. **RISK_LEVEL**: HIGH, MEDIUM, LOW, or NONE
   - Reference specific code from the retrieved chunks if relevant

2. **SUMMARY**: 2-3 sentence summary

3. **DETAILED_ANALYSIS**: Explain your reasoning, citing specific code if applicable

4. **AFFECTED_AREAS**: List specific ECK files/functions affected (from retrieved code or govulncheck)

5. **RECOMMENDATION**: What action to take

6. **CONFIDENCE**: HIGH, MEDIUM, or LOW

Format your response with these exact headers:
RISK_LEVEL: [level]
SUMMARY: [text]
DETAILED_ANALYSIS: [text]
AFFECTED_AREAS:
- [area1]
- [area2]
RECOMMENDATION: [text]
CONFIDENCE: [level]
`)

	return sb.String()
}

