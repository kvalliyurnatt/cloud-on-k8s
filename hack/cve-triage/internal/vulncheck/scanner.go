// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License 2.0;
// you may not use this file except in compliance with the Elastic License 2.0.

package vulncheck

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"os/exec"
	"strings"
)

// Result contains the govulncheck scan results
type Result struct {
	Vulnerabilities []Vulnerability `json:"vulnerabilities"`
	CVEMatches      []Vulnerability `json:"cveMatches"` // Vulnerabilities matching the specific CVE
	Summary         string          `json:"summary"`
	RawOutput       string          `json:"rawOutput"`
}

// Vulnerability represents a single vulnerability found by govulncheck
type Vulnerability struct {
	ID          string   `json:"id"`          // e.g., GO-2024-3321
	CVEs        []string `json:"cves"`        // e.g., CVE-2024-45337
	Package     string   `json:"package"`     // Affected package
	Symbol      string   `json:"symbol"`      // Affected symbol/function
	CalledBy    []string `json:"calledBy"`    // Call stack showing how ECK calls this
	FixedIn     string   `json:"fixedIn"`     // Version that fixes the vulnerability
	Description string   `json:"description"` // Vulnerability description
}

// govulncheckOutput represents the JSON output from govulncheck
type govulncheckOutput struct {
	Vulns []struct {
		OSV struct {
			ID      string `json:"id"`
			Aliases []string `json:"aliases"`
			Summary string `json:"summary"`
			Details string `json:"details"`
		} `json:"osv"`
		Modules []struct {
			Path         string `json:"path"`
			FoundVersion string `json:"found_version"`
			FixedVersion string `json:"fixed_version"`
			Packages     []struct {
				Path    string `json:"path"`
				Callstacks []struct {
					Symbol  string `json:"symbol"`
					Summary string `json:"summary"`
					Frames  []struct {
						Package  string `json:"package"`
						Function string `json:"function"`
						Position struct {
							Filename string `json:"filename"`
							Line     int    `json:"line"`
							Column   int    `json:"column"`
						} `json:"position"`
					} `json:"frames"`
				} `json:"callstacks"`
			} `json:"packages"`
		} `json:"modules"`
	} `json:"vulns"`
}

// Scanner runs govulncheck against the ECK codebase
type Scanner struct {
	repoPath string
}

// NewScanner creates a new govulncheck scanner
func NewScanner(repoPath string) *Scanner {
	return &Scanner{
		repoPath: repoPath,
	}
}

// Scan runs govulncheck and returns the results
func (s *Scanner) Scan(ctx context.Context) (*Result, error) {
	result := &Result{}

	// Check if govulncheck is installed
	if _, err := exec.LookPath("govulncheck"); err != nil {
		return nil, fmt.Errorf("govulncheck not found in PATH. Install with: go install golang.org/x/vuln/cmd/govulncheck@latest")
	}

	// Run govulncheck with JSON output
	cmd := exec.CommandContext(ctx, "govulncheck", "-json", "./...")
	cmd.Dir = s.repoPath

	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	// govulncheck returns exit code 3 if vulnerabilities are found, which is not an error for us
	err := cmd.Run()
	if err != nil {
		if exitErr, ok := err.(*exec.ExitError); ok {
			// Exit code 3 means vulnerabilities found - that's expected
			if exitErr.ExitCode() != 3 && exitErr.ExitCode() != 0 {
				return nil, fmt.Errorf("govulncheck failed: %s", stderr.String())
			}
		} else {
			return nil, fmt.Errorf("failed to run govulncheck: %w", err)
		}
	}

	result.RawOutput = stdout.String()

	// Parse JSON output
	vulns, err := parseGovulncheckOutput(stdout.String())
	if err != nil {
		// If JSON parsing fails, try to extract useful info from raw output
		result.Summary = fmt.Sprintf("govulncheck completed but output parsing failed: %v", err)
		return result, nil
	}

	result.Vulnerabilities = vulns
	result.Summary = s.generateSummary(vulns)

	return result, nil
}

// ScanForCVE runs govulncheck and filters results for a specific CVE
func (s *Scanner) ScanForCVE(ctx context.Context, cveID string) (*Result, error) {
	result, err := s.Scan(ctx)
	if err != nil {
		return nil, err
	}

	// Normalize the CVE ID for matching
	cveID = strings.ToUpper(strings.TrimSpace(cveID))

	// Also extract just the number part for flexible matching
	// e.g., CVE-2025-61727 -> 2025-61727, GO-2025-4175 -> 2025-4175
	cveNumber := cveID
	if strings.HasPrefix(cveID, "CVE-") {
		cveNumber = strings.TrimPrefix(cveID, "CVE-")
	} else if strings.HasPrefix(cveID, "GO-") {
		cveNumber = strings.TrimPrefix(cveID, "GO-")
	}

	for _, vuln := range result.Vulnerabilities {
		matched := false

		// Check if GO ID matches (e.g., GO-2025-4175)
		if strings.ToUpper(vuln.ID) == cveID {
			matched = true
		}

		// Check if any CVE alias matches
		if !matched {
			for _, cve := range vuln.CVEs {
				cve = strings.ToUpper(cve)
				if cve == cveID {
					matched = true
					break
				}
				// Also try partial match (number only)
				if strings.Contains(cve, cveNumber) {
					matched = true
					break
				}
			}
		}

		// Check if GO ID contains the number (for partial matches)
		if !matched && strings.Contains(vuln.ID, cveNumber) {
			matched = true
		}

		if matched {
			result.CVEMatches = append(result.CVEMatches, vuln)
		}
	}

	return result, nil
}

// osvData holds OSV information parsed from govulncheck output
type osvData struct {
	ID          string
	Aliases     []string // CVE IDs
	Summary     string
	Description string
}

// parseGovulncheckOutput parses the JSON output from govulncheck
// govulncheck outputs a stream of JSON objects (pretty-printed, separated by `}\n{`)
func parseGovulncheckOutput(output string) ([]Vulnerability, error) {
	// Split the output into individual JSON objects
	// Each object ends with `}` followed by optional whitespace and `{` for the next object
	objects := splitJSONObjects(output)

	// First pass: collect all OSV data (contains CVE aliases)
	osvMap := make(map[string]*osvData)
	for _, objStr := range objects {
		var msg map[string]interface{}
		if err := json.Unmarshal([]byte(objStr), &msg); err != nil {
			continue
		}

		if osv, ok := msg["osv"].(map[string]interface{}); ok {
			data := &osvData{}

			if idVal, ok := osv["id"].(string); ok {
				data.ID = idVal
			}

			if aliasesVal, ok := osv["aliases"].([]interface{}); ok {
				for _, a := range aliasesVal {
					if alias, ok := a.(string); ok {
						data.Aliases = append(data.Aliases, alias)
					}
				}
			}

			if summary, ok := osv["summary"].(string); ok {
				data.Summary = summary
			}

			if details, ok := osv["details"].(string); ok {
				data.Description = details
			}

			if data.ID != "" {
				osvMap[data.ID] = data
			}
		}
	}

	// Second pass: collect findings and enrich with OSV data
	vulnMap := make(map[string]*Vulnerability)
	for _, objStr := range objects {
		var msg map[string]interface{}
		if err := json.Unmarshal([]byte(objStr), &msg); err != nil {
			continue
		}

		if finding, ok := msg["finding"].(map[string]interface{}); ok {
			osvID := ""
			if osv, ok := finding["osv"].(string); ok {
				osvID = osv
			}

			if osvID == "" {
				continue
			}

			// Get or create vulnerability entry
			vuln, exists := vulnMap[osvID]
			if !exists {
				vuln = &Vulnerability{ID: osvID}
				vulnMap[osvID] = vuln

				// Enrich with OSV data
				if data, ok := osvMap[osvID]; ok {
					vuln.CVEs = data.Aliases
					vuln.Description = data.Summary
				}
			}

			// Extract fixed version
			if fixedVersion, ok := finding["fixed_version"].(string); ok && vuln.FixedIn == "" {
				vuln.FixedIn = fixedVersion
			}

			// Extract call trace
			if trace, ok := finding["trace"].([]interface{}); ok && len(trace) > 0 {
				var tracePackage string
				var traceFunction string
				var traceCalls []string

				for _, frame := range trace {
					if f, ok := frame.(map[string]interface{}); ok {
						if pkg, ok := f["package"].(string); ok {
							if tracePackage == "" {
								tracePackage = pkg
							}
						}
						if fn, ok := f["function"].(string); ok {
							traceFunction = fn
							callStr := fn
							if pkg, ok := f["package"].(string); ok {
								parts := strings.Split(pkg, "/")
								shortPkg := parts[len(parts)-1]
								callStr = shortPkg + "." + fn
							}
							traceCalls = append(traceCalls, callStr)
						}
					}
				}

				// Keep the most detailed trace (with function info)
				if traceFunction != "" {
					if vuln.Package == "" || len(traceCalls) > len(vuln.CalledBy) {
						vuln.Package = tracePackage
						vuln.CalledBy = traceCalls
					}
				} else if vuln.Package == "" && tracePackage != "" {
					vuln.Package = tracePackage
				}
			}
		}
	}

	// Convert map to slice
	var vulns []Vulnerability
	for _, v := range vulnMap {
		vulns = append(vulns, *v)
	}

	return vulns, nil
}

// splitJSONObjects splits a stream of pretty-printed JSON objects
// Each object is separated by `}\n{`
func splitJSONObjects(output string) []string {
	var objects []string
	
	// Track brace depth to find object boundaries
	depth := 0
	start := -1
	inString := false
	escape := false
	
	for i, c := range output {
		if escape {
			escape = false
			continue
		}
		
		if c == '\\' && inString {
			escape = true
			continue
		}
		
		if c == '"' {
			inString = !inString
			continue
		}
		
		if inString {
			continue
		}
		
		if c == '{' {
			if depth == 0 {
				start = i
			}
			depth++
		} else if c == '}' {
			depth--
			if depth == 0 && start >= 0 {
				objects = append(objects, output[start:i+1])
				start = -1
			}
		}
	}
	
	return objects
}

// generateSummary creates a human-readable summary of the scan results
func (s *Scanner) generateSummary(vulns []Vulnerability) string {
	if len(vulns) == 0 {
		return "govulncheck found no vulnerabilities affecting ECK."
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("govulncheck found %d vulnerability(ies) affecting ECK:\n", len(vulns)))

	for _, v := range vulns {
		sb.WriteString(fmt.Sprintf("\n- %s", v.ID))
		if len(v.CVEs) > 0 {
			sb.WriteString(fmt.Sprintf(" (%s)", strings.Join(v.CVEs, ", ")))
		}
		if v.Package != "" {
			sb.WriteString(fmt.Sprintf("\n  Package: %s", v.Package))
		}
		if v.FixedIn != "" {
			sb.WriteString(fmt.Sprintf("\n  Fixed in: %s", v.FixedIn))
		}
		if len(v.CalledBy) > 0 {
			sb.WriteString("\n  Called by: ")
			// Show first few frames of call stack
			maxFrames := 3
			if len(v.CalledBy) < maxFrames {
				maxFrames = len(v.CalledBy)
			}
			sb.WriteString(strings.Join(v.CalledBy[:maxFrames], " → "))
			if len(v.CalledBy) > maxFrames {
				sb.WriteString(" → ...")
			}
		}
	}

	return sb.String()
}

// IsInstalled checks if govulncheck is available
func IsInstalled() bool {
	_, err := exec.LookPath("govulncheck")
	return err == nil
}

// Install attempts to install govulncheck
func Install(ctx context.Context) error {
	cmd := exec.CommandContext(ctx, "go", "install", "golang.org/x/vuln/cmd/govulncheck@latest")
	return cmd.Run()
}

