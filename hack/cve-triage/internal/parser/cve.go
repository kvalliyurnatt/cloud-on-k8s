// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License 2.0;
// you may not use this file except in compliance with the Elastic License 2.0.

package parser

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"regexp"
	"strings"
	"time"
)

// CVEInfo contains parsed CVE information from an issue and NVD data
type CVEInfo struct {
	ID              string   `json:"id"`
	Description     string   `json:"description"`
	Severity        string   `json:"severity"`
	CVSSScore       float64  `json:"cvssScore"`
	AffectedPackages []string `json:"affectedPackages"`
	References      []string `json:"references"`
	PublishedDate   string   `json:"publishedDate"`
	IssueTitle      string   `json:"issueTitle"`
	IssueBody       string   `json:"issueBody"`
}

// cveIDPattern matches CVE identifiers (e.g., CVE-2024-12345)
var cveIDPattern = regexp.MustCompile(`CVE-\d{4}-\d{4,}`)

// Parser handles CVE extraction and NVD lookups
type Parser struct {
	httpClient *http.Client
	nvdAPIKey  string
}

// NewParser creates a new CVE parser
func NewParser(nvdAPIKey string) *Parser {
	return &Parser{
		httpClient: &http.Client{
			Timeout: 30 * time.Second,
		},
		nvdAPIKey: nvdAPIKey,
	}
}

// ParseFromIssue extracts CVE information from a GitHub issue
func (p *Parser) ParseFromIssue(ctx context.Context, issueTitle, issueBody string) (*CVEInfo, error) {
	// Extract CVE ID from title or body
	cveID := extractCVEID(issueTitle)
	if cveID == "" {
		cveID = extractCVEID(issueBody)
	}

	if cveID == "" {
		return nil, fmt.Errorf("no CVE ID found in issue title or body")
	}

	// Fetch CVE details from NVD
	cveInfo, err := p.fetchFromNVD(ctx, cveID)
	if err != nil {
		// If NVD fetch fails, return basic info from the issue
		return &CVEInfo{
			ID:         cveID,
			IssueTitle: issueTitle,
			IssueBody:  issueBody,
		}, nil
	}

	cveInfo.IssueTitle = issueTitle
	cveInfo.IssueBody = issueBody

	return cveInfo, nil
}

// extractCVEID finds the first CVE ID in the given text
func extractCVEID(text string) string {
	match := cveIDPattern.FindString(text)
	return match
}

// ExtractAllCVEIDs finds all CVE IDs in the given text
func ExtractAllCVEIDs(text string) []string {
	matches := cveIDPattern.FindAllString(text, -1)
	// Deduplicate
	seen := make(map[string]bool)
	var unique []string
	for _, m := range matches {
		if !seen[m] {
			seen[m] = true
			unique = append(unique, m)
		}
	}
	return unique
}

// nvdResponse represents the NVD API response structure
type nvdResponse struct {
	Vulnerabilities []struct {
		CVE struct {
			ID          string `json:"id"`
			Description struct {
				DescriptionData []struct {
					Lang  string `json:"lang"`
					Value string `json:"value"`
				} `json:"descriptions"`
			} `json:"descriptions"`
			Metrics struct {
				CVSSMetricV31 []struct {
					CVSSData struct {
						BaseScore    float64 `json:"baseScore"`
						BaseSeverity string  `json:"baseSeverity"`
					} `json:"cvssData"`
				} `json:"cvssMetricV31"`
				CVSSMetricV30 []struct {
					CVSSData struct {
						BaseScore    float64 `json:"baseScore"`
						BaseSeverity string  `json:"baseSeverity"`
					} `json:"cvssData"`
				} `json:"cvssMetricV30"`
				CVSSMetricV2 []struct {
					CVSSData struct {
						BaseScore float64 `json:"baseScore"`
					} `json:"cvssData"`
					BaseSeverity string `json:"baseSeverity"`
				} `json:"cvssMetricV2"`
			} `json:"metrics"`
			References []struct {
				URL string `json:"url"`
			} `json:"references"`
			Published    string `json:"published"`
			Configurations []struct {
				Nodes []struct {
					CPEMatch []struct {
						Criteria string `json:"criteria"`
					} `json:"cpeMatch"`
				} `json:"nodes"`
			} `json:"configurations"`
		} `json:"cve"`
	} `json:"vulnerabilities"`
}

// fetchFromNVD retrieves CVE details from the National Vulnerability Database
func (p *Parser) fetchFromNVD(ctx context.Context, cveID string) (*CVEInfo, error) {
	url := fmt.Sprintf("https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=%s", cveID)

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create NVD request: %w", err)
	}

	req.Header.Set("Accept", "application/json")
	if p.nvdAPIKey != "" {
		req.Header.Set("apiKey", p.nvdAPIKey)
	}

	resp, err := p.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch from NVD: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("NVD API returned status %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read NVD response: %w", err)
	}

	var nvdResp nvdResponse
	if err := json.Unmarshal(body, &nvdResp); err != nil {
		return nil, fmt.Errorf("failed to parse NVD response: %w", err)
	}

	if len(nvdResp.Vulnerabilities) == 0 {
		return nil, fmt.Errorf("CVE %s not found in NVD", cveID)
	}

	cve := nvdResp.Vulnerabilities[0].CVE

	// Extract description (prefer English)
	var description string
	for _, desc := range cve.Description.DescriptionData {
		if desc.Lang == "en" {
			description = desc.Value
			break
		}
	}
	if description == "" && len(cve.Description.DescriptionData) > 0 {
		description = cve.Description.DescriptionData[0].Value
	}

	// Extract severity and score
	var severity string
	var score float64
	if len(cve.Metrics.CVSSMetricV31) > 0 {
		severity = cve.Metrics.CVSSMetricV31[0].CVSSData.BaseSeverity
		score = cve.Metrics.CVSSMetricV31[0].CVSSData.BaseScore
	} else if len(cve.Metrics.CVSSMetricV30) > 0 {
		severity = cve.Metrics.CVSSMetricV30[0].CVSSData.BaseSeverity
		score = cve.Metrics.CVSSMetricV30[0].CVSSData.BaseScore
	} else if len(cve.Metrics.CVSSMetricV2) > 0 {
		severity = cve.Metrics.CVSSMetricV2[0].BaseSeverity
		score = cve.Metrics.CVSSMetricV2[0].CVSSData.BaseScore
	}

	// Extract references
	var references []string
	for _, ref := range cve.References {
		references = append(references, ref.URL)
	}

	// Extract affected packages from CPE data
	var affectedPackages []string
	for _, config := range cve.Configurations {
		for _, node := range config.Nodes {
			for _, match := range node.CPEMatch {
				pkg := extractPackageFromCPE(match.Criteria)
				if pkg != "" {
					affectedPackages = append(affectedPackages, pkg)
				}
			}
		}
	}

	return &CVEInfo{
		ID:               cveID,
		Description:      description,
		Severity:         severity,
		CVSSScore:        score,
		AffectedPackages: affectedPackages,
		References:       references,
		PublishedDate:    cve.Published,
	}, nil
}

// extractPackageFromCPE extracts a readable package name from a CPE string
// CPE format: cpe:2.3:a:vendor:product:version:...
func extractPackageFromCPE(cpe string) string {
	parts := strings.Split(cpe, ":")
	if len(parts) >= 5 {
		vendor := parts[3]
		product := parts[4]
		if vendor != "*" && product != "*" {
			return fmt.Sprintf("%s/%s", vendor, product)
		}
		if product != "*" {
			return product
		}
	}
	return ""
}

