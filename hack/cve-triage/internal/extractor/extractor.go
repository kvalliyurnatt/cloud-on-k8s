// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License 2.0;
// you may not use this file except in compliance with the Elastic License 2.0.

package extractor

import (
	"context"
	"encoding/json"
	"fmt"
	"regexp"
	"strings"

	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/llm"
)

// ExtractedInfo contains structured information extracted from a GitHub issue
type ExtractedInfo struct {
	CVEIDs           []string `json:"cve_ids"`           // e.g., ["CVE-2025-61727"]
	ECKVersion       string   `json:"eck_version"`       // e.g., "3.0.0", or "" if not specified
	AffectedPackages []string `json:"affected_packages"` // e.g., ["crypto/x509"]
	Description      string   `json:"description"`       // Vulnerability description
	Severity         string   `json:"severity"`          // CRITICAL/HIGH/MEDIUM/LOW or ""
	ExtractedBy      string   `json:"extracted_by"`      // "llm" or "regex"
}

// Regex patterns for fallback extraction
var (
	cvePattern     = regexp.MustCompile(`CVE-\d{4}-\d+`)
	versionPattern = regexp.MustCompile(`(?i)(?:ECK|cloud-on-k8s|operator)\s*v?(\d+\.\d+(?:\.\d+)?)`)
	goPackagePattern = regexp.MustCompile(`(?:golang\.org/x?/[\w/.-]+|crypto/[\w]+|net/[\w]+|encoding/[\w]+)`)
	severityPattern = regexp.MustCompile(`(?i)\b(CRITICAL|HIGH|MEDIUM|LOW)\b`)
)

// Extractor extracts structured information from GitHub issues
type Extractor struct{}

// NewExtractor creates a new issue extractor
func NewExtractor() *Extractor {
	return &Extractor{}
}

// Extract extracts information from an issue, using LLM if available, otherwise regex
func (e *Extractor) Extract(ctx context.Context, provider llm.Provider, issueTitle, issueBody string) *ExtractedInfo {
	// If no LLM provider, use regex only
	if provider == nil {
		return e.ExtractWithRegex(issueTitle, issueBody)
	}

	// Check if provider is available
	if !provider.IsAvailable(ctx) {
		return e.ExtractWithRegex(issueTitle, issueBody)
	}

	// Try LLM extraction
	info, err := e.ExtractWithLLM(ctx, provider, issueTitle, issueBody)
	if err != nil {
		// Fall back to regex on error
		fmt.Printf("   ⚠️  LLM extraction failed: %v, falling back to regex\n", err)
		return e.ExtractWithRegex(issueTitle, issueBody)
	}

	return info
}

// ExtractWithLLM uses the LLM provider for intelligent extraction
func (e *Extractor) ExtractWithLLM(ctx context.Context, provider llm.Provider, issueTitle, issueBody string) (*ExtractedInfo, error) {
	prompt := buildExtractionPrompt(issueTitle, issueBody)

	// Use the provider's analyze method with a custom prompt
	// We need to call the underlying method that accepts a prompt
	result, err := extractWithProvider(ctx, provider, prompt)
	if err != nil {
		return nil, err
	}

	return result, nil
}

// extractWithProvider calls the LLM with the extraction prompt
func extractWithProvider(ctx context.Context, provider llm.Provider, prompt string) (*ExtractedInfo, error) {
	// Check if provider supports raw prompt (Ollama or Gemini)
	switch p := provider.(type) {
	case *llm.OllamaAnalyzer:
		return extractWithOllama(ctx, p, prompt)
	case *llm.Analyzer:
		return extractWithGemini(ctx, p, prompt)
	default:
		return nil, fmt.Errorf("provider does not support raw prompt extraction")
	}
}

// extractWithOllama extracts using Ollama
func extractWithOllama(ctx context.Context, ollama *llm.OllamaAnalyzer, prompt string) (*ExtractedInfo, error) {
	response, err := ollama.GenerateRaw(ctx, prompt)
	if err != nil {
		return nil, err
	}

	return parseExtractionResponse(response)
}

// extractWithGemini extracts using Gemini
func extractWithGemini(ctx context.Context, gemini *llm.Analyzer, prompt string) (*ExtractedInfo, error) {
	response, err := gemini.GenerateRaw(ctx, prompt)
	if err != nil {
		return nil, err
	}

	return parseExtractionResponse(response)
}

// buildExtractionPrompt creates the prompt for LLM extraction
func buildExtractionPrompt(issueTitle, issueBody string) string {
	return fmt.Sprintf(`Extract the following information from this GitHub issue about a CVE affecting ECK (Elastic Cloud on Kubernetes).

IMPORTANT: Respond ONLY with valid JSON, no other text.

Extract:
1. cve_ids: List of CVE identifiers (e.g., ["CVE-2024-12345"]). Look for patterns like CVE-YYYY-NNNNN.
2. eck_version: ECK version mentioned (e.g., "3.0.0", "2.14.0") or "" if not specified. Look for version numbers near "ECK", "operator", or "cloud-on-k8s".
3. affected_packages: Go packages affected (e.g., ["crypto/x509", "golang.org/x/crypto"]). Look for Go import paths.
4. description: Brief one-sentence description of the vulnerability.
5. severity: If mentioned explicitly: "CRITICAL", "HIGH", "MEDIUM", or "LOW". Otherwise "".

Issue Title: %s

Issue Body:
%s

Respond with ONLY this JSON structure (no markdown, no explanation):
{"cve_ids": [], "eck_version": "", "affected_packages": [], "description": "", "severity": ""}`, issueTitle, issueBody)
}

// parseExtractionResponse parses the LLM response into ExtractedInfo
func parseExtractionResponse(response string) (*ExtractedInfo, error) {
	// Clean up the response - remove markdown code blocks if present
	response = strings.TrimSpace(response)
	response = strings.TrimPrefix(response, "```json")
	response = strings.TrimPrefix(response, "```")
	response = strings.TrimSuffix(response, "```")
	response = strings.TrimSpace(response)

	// Find JSON in the response (in case there's extra text)
	startIdx := strings.Index(response, "{")
	endIdx := strings.LastIndex(response, "}")
	if startIdx == -1 || endIdx == -1 || endIdx <= startIdx {
		return nil, fmt.Errorf("no valid JSON found in response")
	}
	jsonStr := response[startIdx : endIdx+1]

	var info ExtractedInfo
	if err := json.Unmarshal([]byte(jsonStr), &info); err != nil {
		return nil, fmt.Errorf("failed to parse JSON: %w", err)
	}

	// Normalize version (remove 'v' prefix if present)
	info.ECKVersion = strings.TrimPrefix(info.ECKVersion, "v")
	info.ECKVersion = strings.TrimPrefix(info.ECKVersion, "V")

	// Normalize "not_specified" to empty string
	if info.ECKVersion == "not_specified" || info.ECKVersion == "unknown" {
		info.ECKVersion = ""
	}
	if info.Severity == "not_specified" || info.Severity == "unknown" {
		info.Severity = ""
	}

	info.ExtractedBy = "llm"
	return &info, nil
}

// ExtractWithRegex uses regex patterns for extraction (no LLM required)
func (e *Extractor) ExtractWithRegex(issueTitle, issueBody string) *ExtractedInfo {
	combined := issueTitle + "\n" + issueBody

	info := &ExtractedInfo{
		ExtractedBy: "regex",
	}

	// Extract CVE IDs
	cveMatches := cvePattern.FindAllString(combined, -1)
	seen := make(map[string]bool)
	for _, cve := range cveMatches {
		cve = strings.ToUpper(cve)
		if !seen[cve] {
			info.CVEIDs = append(info.CVEIDs, cve)
			seen[cve] = true
		}
	}

	// Extract ECK version
	if matches := versionPattern.FindStringSubmatch(combined); len(matches) > 1 {
		info.ECKVersion = matches[1]
	}

	// Extract Go packages
	packageMatches := goPackagePattern.FindAllString(combined, -1)
	seenPkg := make(map[string]bool)
	for _, pkg := range packageMatches {
		if !seenPkg[pkg] {
			info.AffectedPackages = append(info.AffectedPackages, pkg)
			seenPkg[pkg] = true
		}
	}

	// Extract severity
	if matches := severityPattern.FindStringSubmatch(combined); len(matches) > 1 {
		info.Severity = strings.ToUpper(matches[1])
	}

	// Extract description (first sentence after CVE ID, or issue title)
	info.Description = extractDescription(issueTitle, issueBody)

	return info
}

// extractDescription extracts a brief description from the issue
func extractDescription(title, body string) string {
	// If title contains CVE, use the part after the CVE ID
	if cvePattern.MatchString(title) {
		// Find text after CVE ID
		parts := cvePattern.Split(title, 2)
		if len(parts) > 1 {
			desc := strings.TrimSpace(parts[1])
			desc = strings.TrimPrefix(desc, "-")
			desc = strings.TrimPrefix(desc, ":")
			desc = strings.TrimSpace(desc)
			if desc != "" {
				return truncateDescription(desc)
			}
		}
	}

	// Use issue title as description
	if title != "" {
		return truncateDescription(title)
	}

	// Extract first sentence from body
	if body != "" {
		// Find first sentence
		endMarkers := []string{". ", ".\n", "!\n", "?\n"}
		minEnd := len(body)
		for _, marker := range endMarkers {
			if idx := strings.Index(body, marker); idx > 0 && idx < minEnd {
				minEnd = idx + 1
			}
		}
		if minEnd < len(body) {
			return truncateDescription(body[:minEnd])
		}
	}

	return ""
}

// truncateDescription truncates description to reasonable length
func truncateDescription(s string) string {
	s = strings.TrimSpace(s)
	if len(s) > 200 {
		return s[:200] + "..."
	}
	return s
}

// String returns a formatted string representation of ExtractedInfo
func (e *ExtractedInfo) String() string {
	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("CVE IDs: %v\n", e.CVEIDs))
	if e.ECKVersion != "" {
		sb.WriteString(fmt.Sprintf("ECK Version: %s\n", e.ECKVersion))
	}
	if len(e.AffectedPackages) > 0 {
		sb.WriteString(fmt.Sprintf("Affected Packages: %v\n", e.AffectedPackages))
	}
	if e.Severity != "" {
		sb.WriteString(fmt.Sprintf("Severity: %s\n", e.Severity))
	}
	if e.Description != "" {
		sb.WriteString(fmt.Sprintf("Description: %s\n", e.Description))
	}
	sb.WriteString(fmt.Sprintf("Extracted by: %s\n", e.ExtractedBy))
	return sb.String()
}

