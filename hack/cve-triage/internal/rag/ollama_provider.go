// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License 2.0;
// you may not use this file except in compliance with the Elastic License 2.0.

package rag

import (
	"context"
	"fmt"
	"os"
)

// OllamaRAGProvider implements RAG using Ollama for embeddings
type OllamaRAGProvider struct {
	embedder    *OllamaEmbedder
	vectorStore *LocalVectorStore
	config      Config
}

// Ensure OllamaRAGProvider implements Provider interface
var _ Provider = (*OllamaRAGProvider)(nil)

// NewOllamaRAGProvider creates a new Ollama-based RAG provider
func NewOllamaRAGProvider(ctx context.Context, cfg Config) (*OllamaRAGProvider, error) {
	// Create embedder
	embedder := NewOllamaEmbedder(cfg.OllamaURL, cfg.OllamaEmbeddingModel)

	// Create vector store
	vectorStore := NewLocalVectorStore()

	// Try to load existing index
	if cfg.IndexPath != "" {
		if _, err := os.Stat(cfg.IndexPath); err == nil {
			if err := vectorStore.Load(cfg.IndexPath); err != nil {
				return nil, fmt.Errorf("failed to load index from %s: %w", cfg.IndexPath, err)
			}
		}
	}

	return &OllamaRAGProvider{
		embedder:    embedder,
		vectorStore: vectorStore,
		config:      cfg,
	}, nil
}

// Name returns the provider name
func (p *OllamaRAGProvider) Name() string {
	return fmt.Sprintf("Ollama RAG (%s, %d chunks)", p.embedder.Model(), p.vectorStore.Size())
}

// Retrieve finds relevant code chunks for a query
func (p *OllamaRAGProvider) Retrieve(ctx context.Context, query string, topK int) ([]SearchResult, error) {
	if p.vectorStore.Size() == 0 {
		return nil, fmt.Errorf("vector store is empty - run 'build-index' first")
	}

	// Generate query embedding
	queryEmb, err := p.embedder.Embed(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("failed to embed query: %w", err)
	}

	// Search vector store
	results := p.vectorStore.Search(queryEmb, topK)

	// Filter by similarity threshold if configured
	if p.config.SimilarityThreshold > 0 {
		var filtered []SearchResult
		for _, r := range results {
			if r.Score >= p.config.SimilarityThreshold {
				filtered = append(filtered, r)
			}
		}
		return filtered, nil
	}

	return results, nil
}

// IsReady checks if the provider is ready to use
func (p *OllamaRAGProvider) IsReady(ctx context.Context) bool {
	// Check if embedder is available
	if !p.embedder.IsAvailable(ctx) {
		return false
	}

	// Check if we have an index
	return p.vectorStore.Size() > 0
}

// IndexSize returns the number of indexed chunks
func (p *OllamaRAGProvider) IndexSize() int {
	return p.vectorStore.Size()
}

// Close releases resources
func (p *OllamaRAGProvider) Close() error {
	return nil
}

// BuildIndex builds the vector index from the repository
func (p *OllamaRAGProvider) BuildIndex(ctx context.Context, repoPath string, progressFn func(current, total int)) error {
	// Chunk the repository
	chunker := NewChunker(repoPath, 2000)
	chunks, err := chunker.ChunkRepository()
	if err != nil {
		return fmt.Errorf("failed to chunk repository: %w", err)
	}

	if len(chunks) == 0 {
		return fmt.Errorf("no code chunks found in repository")
	}

	// Clear existing store
	p.vectorStore.Clear()

	// Generate embeddings and add to store
	total := len(chunks)
	for i, chunk := range chunks {
		if progressFn != nil {
			progressFn(i+1, total)
		}

		emb, err := p.embedder.Embed(ctx, chunk.Content)
		if err != nil {
			// Log error but continue
			fmt.Printf("Warning: failed to embed chunk %s: %v\n", chunk.ID, err)
			continue
		}

		p.vectorStore.Add(chunk, emb)
	}

	// Save index if path configured
	if p.config.IndexPath != "" {
		if err := p.vectorStore.Save(p.config.IndexPath); err != nil {
			return fmt.Errorf("failed to save index: %w", err)
		}
	}

	return nil
}

// SaveIndex saves the current index to disk
func (p *OllamaRAGProvider) SaveIndex(path string) error {
	return p.vectorStore.Save(path)
}

// LoadIndex loads an index from disk
func (p *OllamaRAGProvider) LoadIndex(path string) error {
	return p.vectorStore.Load(path)
}

// Embedder returns the underlying embedder
func (p *OllamaRAGProvider) Embedder() Embedder {
	return p.embedder
}

// VectorStore returns the underlying vector store
func (p *OllamaRAGProvider) VectorStore() VectorStore {
	return p.vectorStore
}

