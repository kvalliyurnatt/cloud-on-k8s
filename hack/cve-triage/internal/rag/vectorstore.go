// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License 2.0;
// you may not use this file except in compliance with the Elastic License 2.0.

package rag

import (
	"encoding/gob"
	"fmt"
	"math"
	"os"
	"sort"
	"sync"
)

// VectorEntry stores a chunk with its embedding
type VectorEntry struct {
	Chunk     CodeChunk
	Embedding []float32
}

// LocalVectorStore is an in-memory vector store with file persistence
type LocalVectorStore struct {
	entries []VectorEntry
	mu      sync.RWMutex
}

// Ensure LocalVectorStore implements VectorStore interface
var _ VectorStore = (*LocalVectorStore)(nil)

// NewLocalVectorStore creates a new vector store
func NewLocalVectorStore() *LocalVectorStore {
	return &LocalVectorStore{
		entries: make([]VectorEntry, 0),
	}
}

// Add adds a chunk with its embedding to the store
func (vs *LocalVectorStore) Add(chunk CodeChunk, embedding []float32) {
	vs.mu.Lock()
	defer vs.mu.Unlock()
	vs.entries = append(vs.entries, VectorEntry{
		Chunk:     chunk,
		Embedding: embedding,
	})
}

// AddBatch adds multiple chunks with their embeddings
func (vs *LocalVectorStore) AddBatch(chunks []CodeChunk, embeddings [][]float32) error {
	if len(chunks) != len(embeddings) {
		return fmt.Errorf("chunks and embeddings length mismatch")
	}
	vs.mu.Lock()
	defer vs.mu.Unlock()
	for i := range chunks {
		vs.entries = append(vs.entries, VectorEntry{
			Chunk:     chunks[i],
			Embedding: embeddings[i],
		})
	}
	return nil
}

// Search finds the top-k most similar chunks to the query embedding
func (vs *LocalVectorStore) Search(queryEmbedding []float32, topK int) []SearchResult {
	vs.mu.RLock()
	defer vs.mu.RUnlock()

	if len(vs.entries) == 0 {
		return nil
	}

	results := make([]SearchResult, len(vs.entries))
	for i, entry := range vs.entries {
		score := cosineSimilarity(queryEmbedding, entry.Embedding)
		results[i] = SearchResult{
			Chunk:    entry.Chunk,
			Score:    score,
			Distance: 1 - score,
		}
	}

	// Sort by score descending
	sort.Slice(results, func(i, j int) bool {
		return results[i].Score > results[j].Score
	})

	if topK > len(results) {
		topK = len(results)
	}

	return results[:topK]
}

// Size returns the number of entries in the store
func (vs *LocalVectorStore) Size() int {
	vs.mu.RLock()
	defer vs.mu.RUnlock()
	return len(vs.entries)
}

// Save persists the vector store to disk
func (vs *LocalVectorStore) Save(path string) error {
	vs.mu.RLock()
	defer vs.mu.RUnlock()

	file, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}
	defer file.Close()

	encoder := gob.NewEncoder(file)
	if err := encoder.Encode(vs.entries); err != nil {
		return fmt.Errorf("failed to encode: %w", err)
	}

	return nil
}

// Load loads a vector store from disk
func (vs *LocalVectorStore) Load(path string) error {
	file, err := os.Open(path)
	if err != nil {
		return fmt.Errorf("failed to open file: %w", err)
	}
	defer file.Close()

	vs.mu.Lock()
	defer vs.mu.Unlock()

	decoder := gob.NewDecoder(file)
	if err := decoder.Decode(&vs.entries); err != nil {
		return fmt.Errorf("failed to decode: %w", err)
	}

	return nil
}

// Clear removes all entries from the store
func (vs *LocalVectorStore) Clear() {
	vs.mu.Lock()
	defer vs.mu.Unlock()
	vs.entries = make([]VectorEntry, 0)
}

// cosineSimilarity calculates cosine similarity between two vectors
func cosineSimilarity(a, b []float32) float32 {
	if len(a) != len(b) || len(a) == 0 {
		return 0
	}

	var dotProduct, normA, normB float64
	for i := range a {
		dotProduct += float64(a[i]) * float64(b[i])
		normA += float64(a[i]) * float64(a[i])
		normB += float64(b[i]) * float64(b[i])
	}

	if normA == 0 || normB == 0 {
		return 0
	}

	return float32(dotProduct / (math.Sqrt(normA) * math.Sqrt(normB)))
}

