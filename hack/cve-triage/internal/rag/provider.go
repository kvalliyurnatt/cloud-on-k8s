// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License 2.0;
// you may not use this file except in compliance with the Elastic License 2.0.

package rag

import (
	"context"
	"fmt"
	"path/filepath"
	"strings"
)

// ProviderType represents the type of RAG provider
type ProviderType string

const (
	ProviderOllama        ProviderType = "ollama"
	ProviderNone          ProviderType = "none"
	// Future providers:
	// ProviderVertexAI      ProviderType = "vertexai"
	// ProviderElasticsearch ProviderType = "elasticsearch"
	// ProviderCodeBERT      ProviderType = "codebert"
)

// SearchResult represents a similarity search result
type SearchResult struct {
	Chunk    CodeChunk
	Score    float32 // Similarity score (higher = more similar)
	Distance float32 // Distance (lower = more similar)
}

// Provider is the interface that all RAG providers must implement
type Provider interface {
	// Name returns the provider name for display
	Name() string

	// Retrieve finds relevant code chunks for a query
	Retrieve(ctx context.Context, query string, topK int) ([]SearchResult, error)

	// IsReady checks if the provider is ready to use
	IsReady(ctx context.Context) bool

	// IndexSize returns the number of indexed chunks
	IndexSize() int

	// Close releases any resources held by the provider
	Close() error
}

// Embedder is the interface for embedding generation
type Embedder interface {
	// Embed generates an embedding for the given text
	Embed(ctx context.Context, text string) ([]float32, error)

	// EmbedBatch generates embeddings for multiple texts
	EmbedBatch(ctx context.Context, texts []string) ([][]float32, error)

	// IsAvailable checks if the embedder is ready
	IsAvailable(ctx context.Context) bool

	// Dimension returns the embedding dimension
	Dimension() int
}

// VectorStore is the interface for vector storage and search
type VectorStore interface {
	// Add adds a chunk with its embedding
	Add(chunk CodeChunk, embedding []float32)

	// Search finds the top-k most similar chunks
	Search(queryEmbedding []float32, topK int) []SearchResult

	// Size returns the number of entries
	Size() int

	// Save persists the store to disk
	Save(path string) error

	// Load loads the store from disk
	Load(path string) error
}

// Config holds configuration for creating a RAG provider
type Config struct {
	// Provider type
	Provider ProviderType

	// Index path (for file-based stores)
	IndexPath string

	// Ollama settings
	OllamaURL           string
	OllamaEmbeddingModel string

	// Repository path (for indexing)
	RepoPath string

	// Search settings
	TopK             int
	SimilarityThreshold float32

	// Future: Vertex AI settings
	// VertexProjectID string
	// VertexCorpus    string

	// Future: Elasticsearch settings
	// ElasticsearchURL   string
	// ElasticsearchIndex string
}

// NewProvider creates a RAG provider based on configuration
func NewProvider(ctx context.Context, cfg Config) (Provider, error) {
	switch cfg.Provider {
	case ProviderOllama:
		return NewOllamaRAGProvider(ctx, cfg)
	case ProviderNone:
		return &NoOpProvider{}, nil
	default:
		return nil, fmt.Errorf("unknown RAG provider type: %s", cfg.Provider)
	}
}

// AvailableProviders returns a list of available provider types
func AvailableProviders() []ProviderType {
	return []ProviderType{
		ProviderOllama,
		ProviderNone,
	}
}

// NoOpProvider is a provider that returns no results
type NoOpProvider struct{}

func (n *NoOpProvider) Name() string {
	return "none (RAG disabled)"
}

func (n *NoOpProvider) Retrieve(ctx context.Context, query string, topK int) ([]SearchResult, error) {
	return nil, nil
}

func (n *NoOpProvider) IsReady(ctx context.Context) bool {
	return true
}

func (n *NoOpProvider) IndexSize() int {
	return 0
}

func (n *NoOpProvider) Close() error {
	return nil
}

// VersionedIndexPath returns an index path with version suffix
// e.g., "data/vectors.gob" + "3.0.0" â†’ "data/vectors-v3.0.0.gob"
// If version is empty, returns the original path or uses "main" as default
func VersionedIndexPath(basePath, version string) string {
	if basePath == "" {
		basePath = "data/vectors.gob"
	}

	// Get directory and base name
	dir := filepath.Dir(basePath)
	base := filepath.Base(basePath)

	// Split base into name and extension
	ext := filepath.Ext(base)
	name := strings.TrimSuffix(base, ext)

	// Normalize version
	if version == "" {
		version = "main"
	} else {
		version = strings.TrimPrefix(version, "v")
		version = strings.TrimPrefix(version, "V")
		version = "v" + version
	}

	// Build new filename
	newName := fmt.Sprintf("%s-%s%s", name, version, ext)

	return filepath.Join(dir, newName)
}

