# RAG Implementation Plan using semantic-code-search-indexer

> **Status**: Planned (not yet implemented)
> **Approach**: Elasticsearch-based RAG with semantic-code-search-indexer
> **Estimated Effort**: 3-5 days
> **Repository**: https://github.com/elastic/semantic-code-search-indexer

## Overview

Use Elastic's [semantic-code-search-indexer](https://github.com/elastic/semantic-code-search-indexer) to index the ECK codebase into Elasticsearch, then query it from the Go-based CVE triage agent to retrieve relevant code context for Gemini analysis.

## Why This Approach

| Benefit | Description |
|---------|-------------|
| **Code-specific embeddings** | Uses CodeBERT (microsoft/codebert-base) trained specifically on code |
| **Production-ready** | Maintained by Elastic with proper observability (OpenTelemetry) |
| **Dual retrieval** | Supports ELSER (sparse) + CodeBERT (dense) vectors |
| **Reusable** | Same index can power developer code search, not just CVE triage |
| **Language-aware chunking** | Parses Go, TypeScript, Python, etc. with language-specific strategies |

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        ECK CVE Triage with Elasticsearch RAG                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                    Indexing Pipeline (Periodic)                      â”‚   â”‚
â”‚  â”‚                                                                      â”‚   â”‚
â”‚  â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚  â”‚   â”‚   ECK    â”‚â”€â”€â”€>â”‚ semantic-code-      â”‚â”€â”€â”€>â”‚  Elasticsearch   â”‚   â”‚   â”‚
â”‚  â”‚   â”‚  Repo    â”‚    â”‚ search-indexer      â”‚    â”‚  (Cloud/Local)   â”‚   â”‚   â”‚
â”‚  â”‚   â”‚  (Git)   â”‚    â”‚ (TypeScript)        â”‚    â”‚                  â”‚   â”‚   â”‚
â”‚  â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚  â”‚                            â”‚                          â”‚             â”‚   â”‚
â”‚  â”‚                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚             â”‚   â”‚
â”‚  â”‚                   â”‚   CodeBERT      â”‚                 â”‚             â”‚   â”‚
â”‚  â”‚                   â”‚   Embeddings    â”‚                 â”‚             â”‚   â”‚
â”‚  â”‚                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚             â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                          â”‚                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                    Query Pipeline (Per CVE)           â”‚             â”‚   â”‚
â”‚  â”‚                                                       â”‚             â”‚   â”‚
â”‚  â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚  â”‚   â”‚   CVE    â”‚â”€â”€â”€>â”‚  Go Triage      â”‚â”€â”€â”€>â”‚  Semantic Search     â”‚   â”‚   â”‚
â”‚  â”‚   â”‚  Issue   â”‚    â”‚  Agent          â”‚    â”‚  (kNN / ELSER)       â”‚   â”‚   â”‚
â”‚  â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚  â”‚                           â”‚                          â”‚              â”‚   â”‚
â”‚  â”‚                           â”‚                          â”‚              â”‚   â”‚
â”‚  â”‚                           â–¼                          â–¼              â”‚   â”‚
â”‚  â”‚                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚  â”‚                   â”‚              Gemini Prompt                  â”‚   â”‚   â”‚
â”‚  â”‚                   â”‚  - CVE Info                                 â”‚   â”‚   â”‚
â”‚  â”‚                   â”‚  - Dependency Analysis                      â”‚   â”‚   â”‚
â”‚  â”‚                   â”‚  - govulncheck Results                      â”‚   â”‚   â”‚
â”‚  â”‚                   â”‚  - Retrieved Code Chunks (from ES)  <â”€ NEW  â”‚   â”‚   â”‚
â”‚  â”‚                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Components

### 1. Elasticsearch Cluster

Options for hosting:

| Option | Pros | Cons | Recommended For |
|--------|------|------|-----------------|
| **Elastic Cloud** | Managed, scalable, ELSER built-in | Cost | Production |
| **Self-hosted ES** | Full control, no ongoing cost | Ops overhead | On-prem |
| **Local (Docker)** | Free, simple for dev | Not for prod | Development |

**Minimum requirements:**
- Elasticsearch 8.12+ (for ELSER v2 and proper histogram support)
- ~2GB RAM for small codebase
- ML node for ELSER/CodeBERT inference

### 2. semantic-code-search-indexer Setup

#### Installation

```bash
# Clone the indexer
git clone https://github.com/elastic/semantic-code-search-indexer.git
cd semantic-code-search-indexer

# Install dependencies
npm install

# Configure environment
cp .env.example .env
```

#### Configuration (.env)

```bash
# Elasticsearch connection
ELASTICSEARCH_URL=https://your-cluster.es.cloud.elastic.co:443
ELASTICSEARCH_API_KEY=your-api-key

# Or username/password
# ELASTICSEARCH_USERNAME=elastic
# ELASTICSEARCH_PASSWORD=changeme

# Index settings
INDEX_NAME=eck-codebase
MAX_CHUNK_SIZE_BYTES=8000

# Optional: Enable dense vectors (CodeBERT)
ENABLE_DENSE_VECTORS=true

# OpenTelemetry (optional)
OTEL_LOGGING_ENABLED=true
OTEL_SERVICE_NAME=eck-code-indexer
```

#### Indexer Ignore File (.indexerignore)

Create in ECK repo root to exclude irrelevant files:

```
# Test files
*_test.go
testdata/

# Generated code
zz_generated*.go

# Vendor
vendor/

# Build artifacts
bin/
*.exe

# Documentation
docs/
*.md

# Config files
*.yaml
*.json
*.toml

# This tool itself
hack/cve-triage/
```

#### Running the Indexer

```bash
# Clone ECK repo
git clone https://github.com/elastic/cloud-on-k8s.git /tmp/eck-repo

# Run indexer
npm run index -- /tmp/eck-repo --clean

# Or with branch specification
npm run index -- /tmp/eck-repo --branch main --clean
```

### 3. Elasticsearch Index Mapping

The indexer creates an index with this structure:

```json
{
  "mappings": {
    "properties": {
      "content": {
        "type": "text",
        "analyzer": "standard"
      },
      "content_semantic": {
        "type": "semantic_text",
        "inference_id": "elser-endpoint"
      },
      "code_vector": {
        "type": "dense_vector",
        "dims": 768,
        "index": true,
        "similarity": "cosine"
      },
      "file_path": { "type": "keyword" },
      "file_name": { "type": "keyword" },
      "language": { "type": "keyword" },
      "kind": { "type": "keyword" },
      "start_line": { "type": "integer" },
      "end_line": { "type": "integer" },
      "repo_name": { "type": "keyword" },
      "repo_branch": { "type": "keyword" }
    }
  }
}
```

### 4. Go Integration Code

#### New Files

```
hack/cve-triage/
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ rag/
â”‚   â”‚   â”œâ”€â”€ elasticsearch.go   # ES client and search
â”‚   â”‚   â”œâ”€â”€ types.go           # Shared types
â”‚   â”‚   â””â”€â”€ formatter.go       # Format results for prompt
```

#### elasticsearch.go

```go
package rag

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/elastic/go-elasticsearch/v8"
)

// Config holds Elasticsearch connection settings
type Config struct {
	Addresses []string
	APIKey    string
	Username  string
	Password  string
	IndexName string
}

// ElasticsearchRetriever queries ES for relevant code chunks
type ElasticsearchRetriever struct {
	client    *elasticsearch.Client
	indexName string
}

// NewElasticsearchRetriever creates a new ES-based retriever
func NewElasticsearchRetriever(cfg Config) (*ElasticsearchRetriever, error) {
	esCfg := elasticsearch.Config{
		Addresses: cfg.Addresses,
	}

	if cfg.APIKey != "" {
		esCfg.APIKey = cfg.APIKey
	} else if cfg.Username != "" {
		esCfg.Username = cfg.Username
		esCfg.Password = cfg.Password
	}

	client, err := elasticsearch.NewClient(esCfg)
	if err != nil {
		return nil, fmt.Errorf("failed to create ES client: %w", err)
	}

	// Verify connection
	res, err := client.Info()
	if err != nil {
		return nil, fmt.Errorf("failed to connect to ES: %w", err)
	}
	defer res.Body.Close()

	if res.IsError() {
		return nil, fmt.Errorf("ES connection error: %s", res.Status())
	}

	return &ElasticsearchRetriever{
		client:    client,
		indexName: cfg.IndexName,
	}, nil
}

// CodeChunk represents a code chunk from Elasticsearch
type CodeChunk struct {
	FilePath   string  `json:"file_path"`
	FileName   string  `json:"file_name"`
	Content    string  `json:"content"`
	Language   string  `json:"language"`
	Kind       string  `json:"kind"` // function, class, method, etc.
	StartLine  int     `json:"start_line"`
	EndLine    int     `json:"end_line"`
	RepoName   string  `json:"repo_name"`
	RepoBranch string  `json:"repo_branch"`
	Score      float64 `json:"_score"`
}

// SearchOptions configures the search behavior
type SearchOptions struct {
	TopK           int
	UseSemanticSearch bool   // Use ELSER semantic search
	UseDenseVector    bool   // Use CodeBERT dense vectors
	FilterLanguage    string // e.g., "go"
	FilterKind        string // e.g., "function"
}

// DefaultSearchOptions returns sensible defaults
func DefaultSearchOptions() SearchOptions {
	return SearchOptions{
		TopK:              15,
		UseSemanticSearch: true,
		UseDenseVector:    false, // ELSER is usually sufficient
		FilterLanguage:    "go",
	}
}

// RetrieveRelevantCode searches for code chunks relevant to the CVE
func (r *ElasticsearchRetriever) RetrieveRelevantCode(
	ctx context.Context,
	cveDescription string,
	affectedPackages []string,
	opts SearchOptions,
) ([]CodeChunk, error) {
	// Build the search query
	query := r.buildSearchQuery(cveDescription, affectedPackages, opts)

	var buf bytes.Buffer
	if err := json.NewEncoder(&buf).Encode(query); err != nil {
		return nil, fmt.Errorf("failed to encode query: %w", err)
	}

	res, err := r.client.Search(
		r.client.Search.WithContext(ctx),
		r.client.Search.WithIndex(r.indexName),
		r.client.Search.WithBody(&buf),
	)
	if err != nil {
		return nil, fmt.Errorf("search failed: %w", err)
	}
	defer res.Body.Close()

	if res.IsError() {
		return nil, fmt.Errorf("search error: %s", res.Status())
	}

	return r.parseSearchResponse(res)
}

// buildSearchQuery constructs the ES query
func (r *ElasticsearchRetriever) buildSearchQuery(
	cveDescription string,
	affectedPackages []string,
	opts SearchOptions,
) map[string]interface{} {
	// Build the query text from CVE info and package names
	queryText := buildQueryText(cveDescription, affectedPackages)

	query := map[string]interface{}{
		"size": opts.TopK,
		"_source": []string{
			"file_path", "file_name", "content", "language",
			"kind", "start_line", "end_line", "repo_name", "repo_branch",
		},
	}

	// Build filters
	var filters []map[string]interface{}
	if opts.FilterLanguage != "" {
		filters = append(filters, map[string]interface{}{
			"term": map[string]interface{}{
				"language": opts.FilterLanguage,
			},
		})
	}
	if opts.FilterKind != "" {
		filters = append(filters, map[string]interface{}{
			"term": map[string]interface{}{
				"kind": opts.FilterKind,
			},
		})
	}

	if opts.UseSemanticSearch {
		// Use ELSER semantic search
		query["query"] = map[string]interface{}{
			"bool": map[string]interface{}{
				"must": []map[string]interface{}{
					{
						"semantic": map[string]interface{}{
							"field": "content_semantic",
							"query": queryText,
						},
					},
				},
				"filter": filters,
			},
		}
	} else if opts.UseDenseVector {
		// Use CodeBERT kNN search
		// Note: Would need to embed the query first
		query["knn"] = map[string]interface{}{
			"field":          "code_vector",
			"query_vector":   nil, // Would need embedding
			"k":              opts.TopK,
			"num_candidates": opts.TopK * 10,
		}
		if len(filters) > 0 {
			query["knn"].(map[string]interface{})["filter"] = map[string]interface{}{
				"bool": map[string]interface{}{
					"filter": filters,
				},
			}
		}
	} else {
		// Fallback to BM25 text search
		query["query"] = map[string]interface{}{
			"bool": map[string]interface{}{
				"must": []map[string]interface{}{
					{
						"multi_match": map[string]interface{}{
							"query":  queryText,
							"fields": []string{"content", "file_path"},
						},
					},
				},
				"filter": filters,
			},
		}
	}

	return query
}

// buildQueryText creates an optimized search query from CVE info
func buildQueryText(cveDescription string, affectedPackages []string) string {
	var parts []string

	// Add package names - these are important for matching imports
	for _, pkg := range affectedPackages {
		// Extract the last part of the package path
		// e.g., "golang.org/x/crypto/ssh" -> "crypto ssh"
		pkgParts := strings.Split(pkg, "/")
		for _, p := range pkgParts {
			if p != "" && p != "x" && p != "golang.org" && p != "github.com" {
				parts = append(parts, p)
			}
		}
	}

	// Add key terms from CVE description
	if cveDescription != "" {
		// Truncate long descriptions
		desc := cveDescription
		if len(desc) > 500 {
			desc = desc[:500]
		}
		parts = append(parts, desc)
	}

	return strings.Join(parts, " ")
}

// parseSearchResponse extracts CodeChunks from ES response
func (r *ElasticsearchRetriever) parseSearchResponse(res *elasticsearch.Response) ([]CodeChunk, error) {
	var result struct {
		Hits struct {
			Hits []struct {
				Score  float64   `json:"_score"`
				Source CodeChunk `json:"_source"`
			} `json:"hits"`
		} `json:"hits"`
	}

	if err := json.NewDecoder(res.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	chunks := make([]CodeChunk, len(result.Hits.Hits))
	for i, hit := range result.Hits.Hits {
		chunks[i] = hit.Source
		chunks[i].Score = hit.Score
	}

	return chunks, nil
}

// Close closes the ES client
func (r *ElasticsearchRetriever) Close() error {
	// go-elasticsearch client doesn't need explicit close
	return nil
}

// SearchByImport finds code that imports a specific package
func (r *ElasticsearchRetriever) SearchByImport(
	ctx context.Context,
	importPath string,
	topK int,
) ([]CodeChunk, error) {
	query := map[string]interface{}{
		"size": topK,
		"query": map[string]interface{}{
			"bool": map[string]interface{}{
				"must": []map[string]interface{}{
					{
						"match_phrase": map[string]interface{}{
							"content": importPath,
						},
					},
				},
				"filter": []map[string]interface{}{
					{
						"term": map[string]interface{}{
							"language": "go",
						},
					},
				},
			},
		},
	}

	var buf bytes.Buffer
	if err := json.NewEncoder(&buf).Encode(query); err != nil {
		return nil, err
	}

	res, err := r.client.Search(
		r.client.Search.WithContext(ctx),
		r.client.Search.WithIndex(r.indexName),
		r.client.Search.WithBody(&buf),
	)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	return r.parseSearchResponse(res)
}
```

#### formatter.go

```go
package rag

import (
	"fmt"
	"strings"
)

// FormatChunksForPrompt formats retrieved chunks for inclusion in the Gemini prompt
func FormatChunksForPrompt(chunks []CodeChunk, maxTokens int) string {
	if len(chunks) == 0 {
		return ""
	}

	var sb strings.Builder
	currentTokens := 0

	sb.WriteString("## Relevant ECK Source Code\n\n")
	sb.WriteString("The following code snippets from ECK are semantically similar to the CVE description.\n")
	sb.WriteString("These were retrieved using CodeBERT embeddings and ELSER semantic search.\n\n")

	for i, chunk := range chunks {
		// Estimate tokens (rough: 4 chars per token)
		chunkTokens := len(chunk.Content) / 4
		headerTokens := 50 // Approximate header size

		if currentTokens+chunkTokens+headerTokens > maxTokens {
			remaining := len(chunks) - i
			sb.WriteString(fmt.Sprintf("\n*... %d more relevant chunks omitted for length ...*\n", remaining))
			break
		}

		// Write chunk header
		sb.WriteString(fmt.Sprintf("### %s\n\n", chunk.FilePath))
		sb.WriteString(fmt.Sprintf("- **Function/Type**: %s\n", chunk.Kind))
		sb.WriteString(fmt.Sprintf("- **Lines**: %d-%d\n", chunk.StartLine, chunk.EndLine))
		sb.WriteString(fmt.Sprintf("- **Relevance Score**: %.2f\n\n", chunk.Score))

		// Write code
		sb.WriteString("```go\n")
		sb.WriteString(chunk.Content)
		if !strings.HasSuffix(chunk.Content, "\n") {
			sb.WriteString("\n")
		}
		sb.WriteString("```\n\n")

		currentTokens += chunkTokens + headerTokens
	}

	return sb.String()
}

// FormatChunksForText formats chunks for CLI text output
func FormatChunksForText(chunks []CodeChunk) string {
	if len(chunks) == 0 {
		return "No relevant code chunks found.\n"
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("Found %d relevant code chunks:\n\n", len(chunks)))

	for i, chunk := range chunks {
		sb.WriteString(fmt.Sprintf("%d. %s (lines %d-%d, score: %.2f)\n",
			i+1, chunk.FilePath, chunk.StartLine, chunk.EndLine, chunk.Score))
		sb.WriteString(fmt.Sprintf("   Type: %s\n", chunk.Kind))
		
		// Show first 100 chars of content
		preview := chunk.Content
		if len(preview) > 100 {
			preview = preview[:100] + "..."
		}
		preview = strings.ReplaceAll(preview, "\n", " ")
		sb.WriteString(fmt.Sprintf("   Preview: %s\n\n", preview))
	}

	return sb.String()
}
```

### 5. Integration with main.go

```go
var (
	// ... existing flags ...
	useRAG          bool
	ragTopK         int
	elasticsearchURL    string
	elasticsearchAPIKey string
	elasticsearchIndex  string
)

func init() {
	// ... existing flags ...
	
	// RAG flags
	rootCmd.Flags().BoolVar(&useRAG, "use-rag", false, 
		"Use Elasticsearch RAG to include relevant source code in analysis")
	rootCmd.Flags().IntVar(&ragTopK, "rag-top-k", 15, 
		"Number of code chunks to retrieve from Elasticsearch")
	rootCmd.Flags().StringVar(&elasticsearchURL, "es-url", "", 
		"Elasticsearch URL (or ES_URL env)")
	rootCmd.Flags().StringVar(&elasticsearchAPIKey, "es-api-key", "", 
		"Elasticsearch API key (or ES_API_KEY env)")
	rootCmd.Flags().StringVar(&elasticsearchIndex, "es-index", "eck-codebase", 
		"Elasticsearch index name")
}

func runTriage(cmd *cobra.Command, args []string) error {
	// ... existing code ...

	// Step X: Retrieve relevant code from Elasticsearch (if enabled)
	var ragChunks []rag.CodeChunk
	if useRAG {
		fmt.Printf("\nğŸ“š Retrieving relevant code from Elasticsearch...\n")

		// Load from env if not set via flags
		if elasticsearchURL == "" {
			elasticsearchURL = os.Getenv("ES_URL")
		}
		if elasticsearchAPIKey == "" {
			elasticsearchAPIKey = os.Getenv("ES_API_KEY")
		}

		if elasticsearchURL == "" {
			fmt.Printf("   âš ï¸  ES_URL not configured, skipping RAG\n")
		} else {
			retriever, err := rag.NewElasticsearchRetriever(rag.Config{
				Addresses: []string{elasticsearchURL},
				APIKey:    elasticsearchAPIKey,
				IndexName: elasticsearchIndex,
			})
			if err != nil {
				fmt.Printf("   âš ï¸  Failed to connect to ES: %v\n", err)
			} else {
				defer retriever.Close()

				opts := rag.DefaultSearchOptions()
				opts.TopK = ragTopK

				ragChunks, err = retriever.RetrieveRelevantCode(ctx,
					cveInfo.Description,
					cveInfo.AffectedPackages,
					opts,
				)
				if err != nil {
					fmt.Printf("   âš ï¸  Search failed: %v\n", err)
				} else {
					fmt.Printf("   âœ… Retrieved %d relevant code chunks\n", len(ragChunks))
				}
			}
		}
	}

	// Pass ragChunks to LLM analyzer
	llmResult, err = analyzer.Analyze(ctx, cveInfo, depResult, vulnResult, ragChunks)
}
```

### 6. Update LLM Analyzer

Add RAG chunks to the prompt in `analyzer.go`:

```go
func buildAnalysisPrompt(
	cveInfo *parser.CVEInfo,
	depResult *deps.CheckResult,
	vulnResult *vulncheck.Result,
	ragChunks []rag.CodeChunk,  // NEW
) string {
	var sb strings.Builder

	// ... existing prompt sections ...

	// Add retrieved code context
	if len(ragChunks) > 0 {
		sb.WriteString(rag.FormatChunksForPrompt(ragChunks, 15000)) // ~15k tokens of code
		sb.WriteString(`
The code above was retrieved using semantic search (ELSER/CodeBERT) based on the CVE description.
These are the ECK code sections most likely to be relevant to this vulnerability.
Consider these code patterns when assessing whether ECK uses the vulnerable functionality.

`)
	}

	// ... rest of prompt ...
}
```

## GitHub Actions Workflows

### Indexing Workflow (Periodic)

Create in ECK repo: `.github/workflows/index-codebase.yml`

```yaml
name: Index Codebase for Semantic Search

on:
  # Run daily
  schedule:
    - cron: '0 2 * * *'
  # Run on main branch pushes
  push:
    branches: [main]
    paths:
      - 'pkg/**'
      - 'cmd/**'
  # Manual trigger
  workflow_dispatch:

jobs:
  index:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout ECK
        uses: actions/checkout@v4

      - name: Checkout semantic-code-search-indexer
        uses: actions/checkout@v4
        with:
          repository: elastic/semantic-code-search-indexer
          path: indexer

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: indexer/package-lock.json

      - name: Install indexer dependencies
        run: |
          cd indexer
          npm ci

      - name: Create .indexerignore
        run: |
          cat > .indexerignore << 'EOF'
          *_test.go
          testdata/
          vendor/
          zz_generated*.go
          docs/
          *.md
          *.yaml
          *.json
          hack/cve-triage/
          EOF

      - name: Run indexer
        env:
          ELASTICSEARCH_URL: ${{ secrets.ES_URL }}
          ELASTICSEARCH_API_KEY: ${{ secrets.ES_API_KEY }}
          INDEX_NAME: eck-codebase
          ENABLE_DENSE_VECTORS: false  # ELSER is sufficient
        run: |
          cd indexer
          npm run index -- ${{ github.workspace }} --branch ${{ github.ref_name }} --clean

      - name: Notify on failure
        if: failure()
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "ECK codebase indexing failed: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
```

### CVE Triage Workflow (Updated)

In security repo: `.github/workflows/eck-cve-triage.yml`

```yaml
name: ECK CVE Triage

on:
  issues:
    types: [opened, labeled]
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to triage'
        required: true
        type: number

permissions:
  issues: write
  contents: read

jobs:
  triage:
    if: contains(github.event.issue.labels.*.name, 'ECK') || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout ECK repository
        uses: actions/checkout@v4
        with:
          repository: elastic/cloud-on-k8s
          ref: main

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache-dependency-path: hack/cve-triage/go.sum

      - name: Install govulncheck
        run: go install golang.org/x/vuln/cmd/govulncheck@latest

      - name: Build CVE Triage Tool
        run: |
          cd hack/cve-triage
          go build -o cve-triage .

      - name: Get Issue Details
        id: issue
        uses: actions/github-script@v7
        with:
          script: |
            let issueNumber;
            if (context.eventName === 'workflow_dispatch') {
              issueNumber = ${{ inputs.issue_number || 0 }};
            } else {
              issueNumber = context.issue.number;
            }
            
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            
            core.setOutput('number', issue.data.number);
            core.setOutput('title', issue.data.title);
            core.setOutput('body', issue.data.body || '');

      - name: Run CVE Triage with RAG
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          ES_URL: ${{ secrets.ES_URL }}
          ES_API_KEY: ${{ secrets.ES_API_KEY }}
        run: |
          cd hack/cve-triage
          ./cve-triage \
            --issue-number=${{ steps.issue.outputs.number }} \
            --issue-title="${{ steps.issue.outputs.title }}" \
            --issue-body="${{ steps.issue.outputs.body }}" \
            --owner=${{ github.repository_owner }} \
            --repo=security \
            --repo-path=../.. \
            --use-rag \
            --rag-top-k=15 \
            --es-index=eck-codebase \
            --add-labels
```

## Dependencies to Add

Update `hack/cve-triage/go.mod`:

```go
require (
    // ... existing deps ...
    github.com/elastic/go-elasticsearch/v8 v8.13.0
)
```

## Secrets Required

| Secret | Where | Description |
|--------|-------|-------------|
| `ES_URL` | ECK repo + Security repo | Elasticsearch cluster URL |
| `ES_API_KEY` | ECK repo + Security repo | Elasticsearch API key |
| `GEMINI_API_KEY` | Security repo | Google Gemini API key |

## CLI Usage

```bash
# Without RAG (current behavior)
./cve-triage --issue-body="CVE-2024-..." --dry-run

# With Elasticsearch RAG
ES_URL=https://your-cluster.es.cloud.elastic.co \
ES_API_KEY=your-key \
./cve-triage \
  --issue-body="CVE-2024-..." \
  --use-rag \
  --rag-top-k=20 \
  --dry-run

# With all options
./cve-triage \
  --issue-number=123 \
  --issue-body="..." \
  --use-rag \
  --es-url=https://... \
  --es-api-key=... \
  --es-index=eck-codebase \
  --rag-top-k=15 \
  --repo-path=/path/to/eck
```

## Cost Estimates

| Component | Cost |
|-----------|------|
| **Elastic Cloud (minimal)** | ~$50-100/month |
| **Indexing (daily)** | Minimal (just API calls) |
| **Queries** | Included in cluster cost |
| **Gemini analysis** | ~$0.02 per triage |

## Example Enhanced Output

With RAG enabled, the triage report will include:

```markdown
## ğŸ” ECK CVE Triage Report

**CVE**: CVE-2024-45337
**Severity**: HIGH (CVSS: 8.1)

### ğŸŸ¢ Risk Level: **NONE**

### Relevant ECK Source Code

The following code snippets from ECK are semantically similar to the CVE description.
These were retrieved using ELSER semantic search from the indexed codebase.

#### pkg/controller/common/certificates/ca.go

- **Function/Type**: function
- **Lines**: 45-78
- **Relevance Score**: 0.89

```go
func (ca *CA) CreateCertificate(template *x509.Certificate) ([]byte, error) {
    // Uses x/crypto for TLS certificate operations
    // NOT using SSH functionality
    ...
}
```

#### pkg/utils/crypto/keys.go

- **Function/Type**: function
- **Lines**: 12-34
- **Relevance Score**: 0.82

```go
func GeneratePrivateKey() (*rsa.PrivateKey, error) {
    // RSA key generation for TLS
    ...
}
```

### AI Analysis

**Summary:**
Based on code analysis, ECK uses golang.org/x/crypto exclusively for TLS/X.509 
certificate operations. The retrieved code shows certificate and RSA key generation,
which are unrelated to the SSH certificate verification vulnerability in CVE-2024-45337.

**Confidence: HIGH** (based on govulncheck + semantic code search)
```

## Comparison with Path A (In-Memory)

| Aspect | Path A (In-Memory) | Path B (Elasticsearch) |
|--------|-------------------|------------------------|
| Setup time | 2-3 days | 3-5 days |
| Infrastructure | None | Elasticsearch cluster |
| Embedding model | Generic (text-embedding-004) | Code-specific (CodeBERT/ELSER) |
| Query quality | Good | Better (code-optimized) |
| Reusability | CVE triage only | Any code search use case |
| Persistence | Rebuild each run | Persistent index |
| Cost | ~$0.02/run (embeddings) | ~$50-100/month (cluster) |
| Maintenance | Self-maintained | Elastic-maintained indexer |

## Future Enhancements

1. **Hybrid search**: Combine ELSER + CodeBERT for best results
2. **Incremental indexing**: Only re-index changed files
3. **Multiple repo support**: Index ECK + related repos
4. **Query expansion**: Use LLM to expand CVE query before search
5. **Feedback loop**: Learn from triage accuracy to improve search

