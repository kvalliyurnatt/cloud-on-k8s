# RAG Implementation Plan: Vertex AI

> **Status**: Planned (not yet implemented)
> **Approach**: Google Cloud Vertex AI managed RAG
> **Estimated Effort**: 1-2 days
> **Prerequisites**: Google Cloud project with Vertex AI enabled

## Overview

Use Google Cloud Vertex AI's managed RAG infrastructure to provide ECK codebase context to Gemini. This is the **simplest implementation** as Vertex AI handles chunking, embedding, vector storage, and retrieval automatically.

## Why Vertex AI RAG

| Aspect | DIY RAG | Vertex AI RAG |
|--------|---------|---------------|
| **Code to write** | ~500+ lines | ~50 lines |
| **Chunking** | Implement | Automatic |
| **Embeddings** | External API | Managed |
| **Vector DB** | Deploy/manage | Managed |
| **Search** | Implement | Built-in |
| **Maintenance** | You | Google |
| **Security** | DIY | Enterprise-grade |
| **Scalability** | Manual | Automatic |

## Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       Vertex AI RAG Architecture                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌───────────────────────────────────────────────────────────────────────┐ │
│  │                    One-Time Setup (via gcloud/Terraform)              │ │
│  │                                                                        │ │
│  │   ┌──────────┐    ┌─────────────┐    ┌────────────────────────────┐   │ │
│  │   │   ECK    │───>│   Cloud     │───>│  Vertex AI RAG Corpus      │   │ │
│  │   │  Source  │    │   Storage   │    │  (auto-chunk, auto-embed,  │   │ │
│  │   │  (Git)   │    │   Bucket    │    │   auto-index)              │   │ │
│  │   └──────────┘    └─────────────┘    └────────────────────────────┘   │ │
│  │                                                                        │ │
│  └───────────────────────────────────────────────────────────────────────┘ │
│                                                                             │
│  ┌───────────────────────────────────────────────────────────────────────┐ │
│  │                    Runtime (Per CVE Triage)                           │ │
│  │                                                                        │ │
│  │   ┌──────────┐                      ┌────────────────────────────┐    │ │
│  │   │   CVE    │                      │      Vertex AI RAG         │    │ │
│  │   │  Issue   │                      │         Corpus             │    │ │
│  │   └────┬─────┘                      └─────────────┬──────────────┘    │ │
│  │        │                                          │                   │ │
│  │        ▼                                          │                   │ │
│  │   ┌─────────────────────────────────────────────────────────────┐    │ │
│  │   │                    Gemini 2.0 Flash                          │    │ │
│  │   │                    (with RAG Tool)                           │    │ │
│  │   │                                                              │    │ │
│  │   │  1. Receives CVE query                                       │    │ │
│  │   │  2. Automatically searches corpus for relevant code         │    │ │
│  │   │  3. Includes retrieved chunks in context                    │    │ │
│  │   │  4. Generates grounded response                             │    │ │
│  │   │                                                              │    │ │
│  │   └─────────────────────────────────────────────────────────────┘    │ │
│  │                              │                                        │ │
│  │                              ▼                                        │ │
│  │                     ┌─────────────────┐                              │ │
│  │                     │  Triage Report  │                              │ │
│  │                     │  (with code     │                              │ │
│  │                     │   citations)    │                              │ │
│  │                     └─────────────────┘                              │ │
│  │                                                                        │ │
│  └───────────────────────────────────────────────────────────────────────┘ │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

## Setup Instructions

### Prerequisites

```bash
# Install gcloud CLI
# https://cloud.google.com/sdk/docs/install

# Login
gcloud auth login
gcloud auth application-default login

# Set project
export PROJECT_ID="your-gcp-project"
gcloud config set project $PROJECT_ID

# Enable required APIs
gcloud services enable aiplatform.googleapis.com
gcloud services enable storage.googleapis.com
gcloud services enable discoveryengine.googleapis.com
```

### Step 1: Create Cloud Storage Bucket

```bash
export BUCKET_NAME="${PROJECT_ID}-eck-codebase"
export REGION="us-central1"

# Create bucket
gcloud storage buckets create gs://${BUCKET_NAME} \
  --location=${REGION}
```

### Step 2: Upload ECK Source Code

```bash
# Clone ECK repo
git clone https://github.com/elastic/cloud-on-k8s.git /tmp/eck

# Upload Go source files (exclude tests, vendor, generated)
cd /tmp/eck
find . -name "*.go" \
  ! -name "*_test.go" \
  ! -path "./vendor/*" \
  ! -name "zz_generated*" \
  ! -path "./hack/cve-triage/*" \
  -exec gsutil cp {} gs://${BUCKET_NAME}/code/{} \;

# Or use gsutil with parallel upload
gsutil -m rsync -r \
  --exclude=".*_test\.go$" \
  --exclude=".*/vendor/.*" \
  --exclude=".*zz_generated.*" \
  ./pkg gs://${BUCKET_NAME}/code/pkg/

gsutil -m rsync -r \
  --exclude=".*_test\.go$" \
  ./cmd gs://${BUCKET_NAME}/code/cmd/
```

### Step 3: Create RAG Corpus

```bash
# Create the RAG corpus (data store)
gcloud alpha ai rag-corpora create \
  --display-name="ECK Codebase" \
  --description="Elastic Cloud on Kubernetes source code for CVE analysis" \
  --location=${REGION}

# Note the corpus name from output, e.g.:
# projects/123456/locations/us-central1/ragCorpora/eck-codebase-12345
export CORPUS_NAME="projects/${PROJECT_ID}/locations/${REGION}/ragCorpora/YOUR_CORPUS_ID"
```

### Step 4: Import Files into Corpus

```bash
# Import from Cloud Storage
gcloud alpha ai rag-corpora import \
  --corpus=${CORPUS_NAME} \
  --location=${REGION} \
  --source="gs://${BUCKET_NAME}/code/**/*.go" \
  --chunk-size=1024 \
  --chunk-overlap=200
```

### Step 5: Verify Corpus

```bash
# Check corpus status
gcloud alpha ai rag-corpora describe ${CORPUS_NAME} \
  --location=${REGION}

# List files in corpus
gcloud alpha ai rag-corpora files list \
  --corpus=${CORPUS_NAME} \
  --location=${REGION}
```

## Code Implementation

### Updated Analyzer (`analyzer.go`)

```go
// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License 2.0;
// you may not use this file except in compliance with the Elastic License 2.0.

package llm

import (
	"context"
	"fmt"
	"strings"

	"cloud.google.com/go/vertexai/genai"
	
	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/deps"
	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/parser"
	"github.com/elastic/cloud-on-k8s/v3/hack/cve-triage/internal/vulncheck"
)

// AnalyzerConfig configures the LLM analyzer
type AnalyzerConfig struct {
	// Google AI Studio (simple)
	APIKey string
	
	// Vertex AI (enterprise)
	UseVertexAI bool
	ProjectID   string
	Location    string
	
	// Vertex AI RAG
	UseRAG     bool
	CorpusName string // e.g., "projects/xxx/locations/us-central1/ragCorpora/eck-codebase"
}

// Analyzer uses Gemini to analyze CVE impact on ECK
type Analyzer struct {
	client *genai.Client
	model  *genai.GenerativeModel
	useRAG bool
}

// NewAnalyzer creates a new LLM analyzer
func NewAnalyzer(ctx context.Context, cfg AnalyzerConfig) (*Analyzer, error) {
	var client *genai.Client
	var err error

	if cfg.UseVertexAI {
		// Vertex AI client (uses Application Default Credentials)
		client, err = genai.NewClient(ctx, cfg.ProjectID, cfg.Location)
		if err != nil {
			return nil, fmt.Errorf("failed to create Vertex AI client: %w", err)
		}
	} else {
		// Google AI Studio client (API key)
		client, err = genai.NewClient(ctx, option.WithAPIKey(cfg.APIKey))
		if err != nil {
			return nil, fmt.Errorf("failed to create Gemini client: %w", err)
		}
	}

	model := client.GenerativeModel("gemini-2.0-flash")
	model.SetTemperature(0.2)
	model.SetTopP(0.8)

	// Enable RAG grounding if configured
	if cfg.UseRAG && cfg.CorpusName != "" {
		model.Tools = []*genai.Tool{{
			Retrieval: &genai.Retrieval{
				VertexRagStore: &genai.VertexRagStore{
					RagCorpora: []string{cfg.CorpusName},
					// Similarity threshold (0-1, higher = more relevant)
					SimilarityTopK: 10,
				},
			},
		}}
	}

	return &Analyzer{
		client: client,
		model:  model,
		useRAG: cfg.UseRAG,
	}, nil
}

// Close releases the client resources
func (a *Analyzer) Close() error {
	return a.client.Close()
}

// Analyze performs LLM-based analysis of the CVE's impact on ECK
func (a *Analyzer) Analyze(
	ctx context.Context,
	cveInfo *parser.CVEInfo,
	depResult *deps.CheckResult,
	vulnResult *vulncheck.Result,
) (*AnalysisResult, error) {
	prompt := a.buildPrompt(cveInfo, depResult, vulnResult)

	resp, err := a.model.GenerateContent(ctx, genai.Text(prompt))
	if err != nil {
		return nil, fmt.Errorf("failed to generate analysis: %w", err)
	}

	if len(resp.Candidates) == 0 || len(resp.Candidates[0].Content.Parts) == 0 {
		return nil, fmt.Errorf("no response from Gemini")
	}

	// Extract text and grounding metadata
	var responseText string
	var groundingChunks []GroundingChunk
	
	for _, part := range resp.Candidates[0].Content.Parts {
		if text, ok := part.(genai.Text); ok {
			responseText += string(text)
		}
	}

	// Extract grounding metadata (retrieved code chunks)
	if resp.Candidates[0].GroundingMetadata != nil {
		for _, chunk := range resp.Candidates[0].GroundingMetadata.GroundingChunks {
			if chunk.RetrievedContext != nil {
				groundingChunks = append(groundingChunks, GroundingChunk{
					URI:     chunk.RetrievedContext.URI,
					Title:   chunk.RetrievedContext.Title,
					Content: chunk.RetrievedContext.Text,
				})
			}
		}
	}

	result := parseAnalysisResponse(responseText)
	result.GroundingChunks = groundingChunks
	
	return result, nil
}

// buildPrompt creates the analysis prompt
// When RAG is enabled, Gemini automatically retrieves and includes relevant code
func (a *Analyzer) buildPrompt(
	cveInfo *parser.CVEInfo,
	depResult *deps.CheckResult,
	vulnResult *vulncheck.Result,
) string {
	var sb strings.Builder

	sb.WriteString(`You are a security analyst specializing in Kubernetes operators and Go applications.
Analyze the following CVE and determine its impact on ECK (Elastic Cloud on Kubernetes).

ECK is a Kubernetes operator that manages Elasticsearch, Kibana, APM Server, Enterprise Search,
Beats, Elastic Agent, Elastic Maps Server, and Logstash deployments on Kubernetes.

`)

	// When RAG is enabled, add instruction to use retrieved code
	if a.useRAG {
		sb.WriteString(`IMPORTANT: You have access to the ECK source code via retrieval. 
Search for and cite specific code that:
1. Imports or uses the affected packages
2. Contains functions that might be vulnerable
3. Shows how ECK uses the affected functionality

Include specific file paths and code snippets in your analysis.

`)
	}

	sb.WriteString("## CVE Information\n\n")
	sb.WriteString(fmt.Sprintf("**CVE ID**: %s\n", cveInfo.ID))
	sb.WriteString(fmt.Sprintf("**Severity**: %s (CVSS: %.1f)\n", cveInfo.Severity, cveInfo.CVSSScore))
	sb.WriteString(fmt.Sprintf("**Description**: %s\n\n", cveInfo.Description))

	if len(cveInfo.AffectedPackages) > 0 {
		sb.WriteString("**Affected Packages**:\n")
		for _, pkg := range cveInfo.AffectedPackages {
			sb.WriteString(fmt.Sprintf("- %s\n", pkg))
		}
		sb.WriteString("\n")
	}

	// Add dependency analysis
	sb.WriteString("## Dependency Analysis\n\n")
	if depResult.CVEAffectsECK {
		sb.WriteString("Potential matches found in ECK dependencies:\n")
		for _, m := range depResult.DirectMatches {
			sb.WriteString(fmt.Sprintf("- Direct: %s@%s\n", m.Dependency.Path, m.Dependency.Version))
		}
		for _, m := range depResult.TransitiveMatches {
			sb.WriteString(fmt.Sprintf("- Transitive: %s@%s\n", m.Dependency.Path, m.Dependency.Version))
		}
	} else {
		sb.WriteString("No matching dependencies found in ECK's go.mod.\n")
	}
	sb.WriteString("\n")

	// Add govulncheck results
	sb.WriteString("## govulncheck Results\n\n")
	if vulnResult != nil && len(vulnResult.CVEMatches) > 0 {
		sb.WriteString("**CRITICAL: govulncheck confirms ECK calls vulnerable code:**\n")
		for _, v := range vulnResult.CVEMatches {
			sb.WriteString(fmt.Sprintf("- %s in %s\n", v.ID, v.Package))
			if len(v.CalledBy) > 0 {
				sb.WriteString(fmt.Sprintf("  Call path: %s\n", strings.Join(v.CalledBy, " → ")))
			}
		}
	} else if vulnResult != nil {
		sb.WriteString("govulncheck found no vulnerabilities affecting ECK.\n")
	} else {
		sb.WriteString("govulncheck was not run.\n")
	}
	sb.WriteString("\n")

	// Analysis task
	sb.WriteString(`## Your Analysis Task

Based on the CVE information, dependency analysis, govulncheck results, and ECK source code (retrieved via RAG), provide:

1. **RISK_LEVEL**: HIGH, MEDIUM, LOW, or NONE
2. **SUMMARY**: 2-3 sentence summary
3. **DETAILED_ANALYSIS**: Your reasoning with specific code citations
4. **AFFECTED_AREAS**: List specific ECK files/functions affected
5. **RECOMMENDATION**: What action to take
6. **CONFIDENCE**: HIGH, MEDIUM, or LOW

Format your response with these exact headers.
`)

	return sb.String()
}

// GroundingChunk represents a retrieved code chunk
type GroundingChunk struct {
	URI     string `json:"uri"`
	Title   string `json:"title"`
	Content string `json:"content"`
}

// AnalysisResult includes grounding information
type AnalysisResult struct {
	RiskLevel        string           `json:"riskLevel"`
	Summary          string           `json:"summary"`
	DetailedAnalysis string           `json:"detailedAnalysis"`
	Recommendation   string           `json:"recommendation"`
	Confidence       string           `json:"confidence"`
	AffectedAreas    []string         `json:"affectedAreas"`
	GroundingChunks  []GroundingChunk `json:"groundingChunks,omitempty"`
}
```

### Updated main.go Flags

```go
var (
	// ... existing flags ...
	
	// Vertex AI flags
	useVertexAI  bool
	gcpProject   string
	gcpLocation  string
	
	// RAG flags
	useRAG      bool
	ragCorpus   string
)

func init() {
	// ... existing flags ...
	
	// Vertex AI
	rootCmd.Flags().BoolVar(&useVertexAI, "use-vertex-ai", false,
		"Use Vertex AI instead of Google AI Studio")
	rootCmd.Flags().StringVar(&gcpProject, "gcp-project", "",
		"Google Cloud project ID (or GCP_PROJECT env)")
	rootCmd.Flags().StringVar(&gcpLocation, "gcp-location", "us-central1",
		"Vertex AI location")
	
	// RAG
	rootCmd.Flags().BoolVar(&useRAG, "use-rag", false,
		"Enable RAG with Vertex AI corpus")
	rootCmd.Flags().StringVar(&ragCorpus, "rag-corpus", "",
		"Vertex AI RAG corpus name (or RAG_CORPUS env)")
}

func runTriage(cmd *cobra.Command, args []string) error {
	// ... setup ...
	
	// Configure analyzer
	analyzerCfg := llm.AnalyzerConfig{
		UseVertexAI: useVertexAI,
		UseRAG:      useRAG,
	}
	
	if useVertexAI {
		if gcpProject == "" {
			gcpProject = os.Getenv("GCP_PROJECT")
		}
		analyzerCfg.ProjectID = gcpProject
		analyzerCfg.Location = gcpLocation
		
		if useRAG {
			if ragCorpus == "" {
				ragCorpus = os.Getenv("RAG_CORPUS")
			}
			analyzerCfg.CorpusName = ragCorpus
		}
	} else {
		analyzerCfg.APIKey = geminiAPIKey
	}
	
	analyzer, err := llm.NewAnalyzer(ctx, analyzerCfg)
	if err != nil {
		return fmt.Errorf("failed to create analyzer: %w", err)
	}
	defer analyzer.Close()
	
	// ... rest of triage ...
}
```

### Updated go.mod

```go
require (
	cloud.google.com/go/vertexai v0.7.0  // For Vertex AI
	// ... existing deps ...
)
```

## CLI Usage

### Without RAG (Current Behavior)

```bash
# Google AI Studio
GEMINI_API_KEY=xxx ./cve-triage \
  --issue-body="CVE-2024-45337..." \
  --dry-run

# Vertex AI (no RAG)
./cve-triage \
  --use-vertex-ai \
  --gcp-project=my-project \
  --issue-body="CVE-2024-45337..." \
  --dry-run
```

### With RAG

```bash
# Vertex AI with RAG
./cve-triage \
  --use-vertex-ai \
  --gcp-project=my-project \
  --use-rag \
  --rag-corpus="projects/my-project/locations/us-central1/ragCorpora/eck-codebase" \
  --issue-body="CVE-2024-45337..." \
  --dry-run
```

## GitHub Actions

### Corpus Update Workflow (Weekly)

```yaml
# .github/workflows/update-rag-corpus.yml
name: Update RAG Corpus

on:
  schedule:
    - cron: '0 0 * * 0'  # Weekly on Sunday
  push:
    branches: [main]
    paths:
      - 'pkg/**'
      - 'cmd/**'
  workflow_dispatch:

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  REGION: us-central1
  BUCKET_NAME: ${{ secrets.GCP_PROJECT_ID }}-eck-codebase
  CORPUS_NAME: ${{ secrets.RAG_CORPUS_NAME }}

jobs:
  update-corpus:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write  # For Workload Identity Federation
    
    steps:
      - uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.WIF_PROVIDER }}
          service_account: ${{ secrets.WIF_SERVICE_ACCOUNT }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Upload source code to GCS
        run: |
          # Upload Go files (exclude tests, vendor, generated)
          find . -name "*.go" \
            ! -name "*_test.go" \
            ! -path "./vendor/*" \
            ! -name "zz_generated*" \
            ! -path "./hack/cve-triage/*" \
            -print0 | \
          xargs -0 -I {} gsutil cp {} gs://${BUCKET_NAME}/code/{}

      - name: Refresh RAG corpus
        run: |
          # Delete old files and re-import
          gcloud alpha ai rag-corpora files delete-all \
            --corpus=${CORPUS_NAME} \
            --location=${REGION} \
            --quiet || true
          
          gcloud alpha ai rag-corpora import \
            --corpus=${CORPUS_NAME} \
            --location=${REGION} \
            --source="gs://${BUCKET_NAME}/code/**/*.go" \
            --chunk-size=1024 \
            --chunk-overlap=200
```

### CVE Triage Workflow

```yaml
# .github/workflows/eck-cve-triage.yml
name: ECK CVE Triage

on:
  issues:
    types: [opened, labeled]

jobs:
  triage:
    if: contains(github.event.issue.labels.*.name, 'ECK')
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      id-token: write

    steps:
      - uses: actions/checkout@v4
        with:
          repository: elastic/cloud-on-k8s

      - uses: actions/setup-go@v5
        with:
          go-version: '1.24'

      - name: Install govulncheck
        run: go install golang.org/x/vuln/cmd/govulncheck@latest

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.WIF_PROVIDER }}
          service_account: ${{ secrets.WIF_SERVICE_ACCOUNT }}

      - name: Run CVE Triage with Vertex AI RAG
        env:
          GCP_PROJECT: ${{ secrets.GCP_PROJECT_ID }}
          RAG_CORPUS: ${{ secrets.RAG_CORPUS_NAME }}
        run: |
          cd hack/cve-triage
          go run . \
            --use-vertex-ai \
            --gcp-project=${GCP_PROJECT} \
            --use-rag \
            --rag-corpus=${RAG_CORPUS} \
            --issue-number=${{ github.event.issue.number }} \
            --issue-body="${{ github.event.issue.body }}" \
            --repo-path=../.. \
            --add-labels
```

## Cost Estimates

| Component | Cost |
|-----------|------|
| **Cloud Storage** | ~$0.02/GB/month |
| **Vertex AI RAG queries** | ~$0.10 per 1k queries |
| **Gemini 2.0 Flash** | ~$0.075 per 1M tokens |
| **Monthly estimate** | ~$5-20 for typical usage |

## IAM Permissions Required

```bash
# Service account needs these roles:
gcloud projects add-iam-policy-binding ${PROJECT_ID} \
  --member="serviceAccount:${SA_EMAIL}" \
  --role="roles/aiplatform.user"

gcloud projects add-iam-policy-binding ${PROJECT_ID} \
  --member="serviceAccount:${SA_EMAIL}" \
  --role="roles/storage.objectViewer"

gcloud projects add-iam-policy-binding ${PROJECT_ID} \
  --member="serviceAccount:${SA_EMAIL}" \
  --role="roles/discoveryengine.viewer"
```

## Comparison with Other RAG Plans

| Aspect | CodeBERT (HF) | Elasticsearch | **Vertex AI** |
|--------|---------------|---------------|---------------|
| **Setup effort** | 2-3 days | 3-5 days | **1-2 days** ✅ |
| **Code to write** | ~500 lines | ~300 lines | **~50 lines** ✅ |
| **Infrastructure** | None | ES Cluster | **Managed** ✅ |
| **Embedding model** | CodeBERT | ELSER/CodeBERT | Google's |
| **Maintenance** | You | You | **Google** ✅ |
| **Enterprise security** | DIY | Good | **Best** ✅ |
| **Monthly cost** | ~$0 (free tier) | ~$50-100 | ~$5-20 |
| **Scalability** | Manual | Manual | **Automatic** ✅ |

## Summary

**Vertex AI RAG is the simplest and most maintainable solution:**

1. ✅ **Minimal code** - Just configure the model with a RAG tool
2. ✅ **No infrastructure** - Google manages everything
3. ✅ **Automatic updates** - Just re-import files when code changes
4. ✅ **Enterprise-ready** - IAM, VPC, audit logs, SLAs
5. ✅ **Integrated** - Grounding metadata shows what code was retrieved
6. ✅ **Cost-effective** - Pay only for what you use

**Trade-offs:**
- Requires Google Cloud project
- Vendor lock-in to GCP
- Less control over chunking/embedding

## Files to Modify

| File | Changes |
|------|---------|
| `internal/llm/analyzer.go` | Add Vertex AI client + RAG tool configuration |
| `main.go` | Add Vertex AI and RAG flags |
| `go.mod` | Add `cloud.google.com/go/vertexai` |

## Next Steps

1. Create GCP project (if needed)
2. Enable Vertex AI API
3. Create Cloud Storage bucket
4. Upload ECK source code
5. Create RAG corpus
6. Import files into corpus
7. Update analyzer code
8. Test with `--use-vertex-ai --use-rag`

