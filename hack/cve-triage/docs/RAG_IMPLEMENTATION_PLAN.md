# RAG Implementation Plan for ECK CVE Triage

> **Status**: Planned (not yet implemented)
> **Approach**: Path A - Simple In-Memory RAG
> **Estimated Effort**: 2-3 days

## Overview

Add Retrieval-Augmented Generation (RAG) to provide Gemini with relevant ECK source code context when analyzing CVEs. This will enable more accurate analysis by showing the AI exactly how ECK uses potentially vulnerable dependencies.

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     CVE Triage with RAG                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚  ECK Source  â”‚â”€â”€â”€>â”‚ Code Chunker â”‚â”€â”€â”€>â”‚  Embedder    â”‚      â”‚
â”‚  â”‚    Files     â”‚    â”‚  (Go AST)    â”‚    â”‚ (Google API) â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                 â”‚               â”‚
â”‚                                                 â–¼               â”‚
â”‚                                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚                                          â”‚  In-Memory   â”‚      â”‚
â”‚                                          â”‚ Vector Store â”‚      â”‚
â”‚                                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                                                 â”‚               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                              â”‚               â”‚
â”‚  â”‚ CVE + Deps   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤               â”‚
â”‚  â”‚   Context    â”‚                              â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                              â–¼               â”‚
â”‚         â”‚                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚         â”‚                              â”‚  Retriever   â”‚        â”‚
â”‚         â”‚                              â”‚ (Top-K sim)  â”‚        â”‚
â”‚         â”‚                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚         â”‚                                      â”‚               â”‚
â”‚         â–¼                                      â–¼               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚                   Gemini Prompt                      â”‚       â”‚
â”‚  â”‚  - CVE Info                                         â”‚       â”‚
â”‚  â”‚  - Dependency Analysis                              â”‚       â”‚
â”‚  â”‚  - govulncheck Results                              â”‚       â”‚
â”‚  â”‚  - Retrieved Code Chunks  <â”€â”€ NEW                   â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                              â”‚                                  â”‚
â”‚                              â–¼                                  â”‚
â”‚                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”‚
â”‚                     â”‚   Analysis   â”‚                           â”‚
â”‚                     â”‚    Result    â”‚                           â”‚
â”‚                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## New Files to Create

```
hack/cve-triage/
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ rag/
â”‚   â”‚   â”œâ”€â”€ chunker.go      # Parse Go code into semantic chunks
â”‚   â”‚   â”œâ”€â”€ embedder.go     # Generate embeddings via Google API
â”‚   â”‚   â”œâ”€â”€ store.go        # In-memory vector storage
â”‚   â”‚   â”œâ”€â”€ retriever.go    # Similarity search
â”‚   â”‚   â””â”€â”€ types.go        # Shared types
```

## Implementation Details

### 1. Code Chunker (`chunker.go`)

Parses Go source files into meaningful chunks using Go's AST parser.

```go
package rag

import (
    "go/ast"
    "go/parser"
    "go/token"
)

// ChunkType represents the type of code chunk
type ChunkType string

const (
    ChunkTypeFunction ChunkType = "function"
    ChunkTypeMethod   ChunkType = "method"
    ChunkTypeType     ChunkType = "type"
    ChunkTypeFile     ChunkType = "file"
)

// CodeChunk represents a semantic unit of code
type CodeChunk struct {
    ID        string    // Unique identifier
    FilePath  string    // Path relative to repo root
    Package   string    // Go package name
    Name      string    // Function/type name
    Type      ChunkType
    StartLine int
    EndLine   int
    Content   string    // Actual source code
    Imports   []string  // Imports used by this chunk
    Signature string    // Function/type signature (for context)
}

// Chunker parses Go code into chunks
type Chunker struct {
    repoPath string
    fset     *token.FileSet
}

// NewChunker creates a new code chunker
func NewChunker(repoPath string) *Chunker {
    return &Chunker{
        repoPath: repoPath,
        fset:     token.NewFileSet(),
    }
}

// ChunkRepository walks the repo and creates chunks from all Go files
func (c *Chunker) ChunkRepository() ([]CodeChunk, error) {
    var chunks []CodeChunk
    
    // Walk all .go files (excluding test files, vendor, etc.)
    // For each file:
    //   1. Parse with go/parser
    //   2. Extract functions, methods, types
    //   3. Create CodeChunk for each
    
    return chunks, nil
}

// chunkFile parses a single Go file into chunks
func (c *Chunker) chunkFile(filePath string) ([]CodeChunk, error) {
    // Parse the file
    file, err := parser.ParseFile(c.fset, filePath, nil, parser.ParseComments)
    if err != nil {
        return nil, err
    }
    
    var chunks []CodeChunk
    
    // Extract imports for context
    var imports []string
    for _, imp := range file.Imports {
        imports = append(imports, imp.Path.Value)
    }
    
    // Walk AST and extract functions, methods, types
    ast.Inspect(file, func(n ast.Node) bool {
        switch decl := n.(type) {
        case *ast.FuncDecl:
            chunk := c.extractFunction(filePath, file.Name.Name, decl, imports)
            chunks = append(chunks, chunk)
        case *ast.GenDecl:
            // Handle type declarations
            for _, spec := range decl.Specs {
                if typeSpec, ok := spec.(*ast.TypeSpec); ok {
                    chunk := c.extractType(filePath, file.Name.Name, typeSpec, imports)
                    chunks = append(chunks, chunk)
                }
            }
        }
        return true
    })
    
    return chunks, nil
}
```

### 2. Embedder (`embedder.go`)

Generates embeddings using Google's text-embedding API.

```go
package rag

import (
    "context"
    
    "github.com/google/generative-ai-go/genai"
    "google.golang.org/api/option"
)

// Embedder generates text embeddings
type Embedder struct {
    client *genai.Client
    model  *genai.EmbeddingModel
}

// NewEmbedder creates a new embedder using Google's API
func NewEmbedder(ctx context.Context, apiKey string) (*Embedder, error) {
    client, err := genai.NewClient(ctx, option.WithAPIKey(apiKey))
    if err != nil {
        return nil, err
    }
    
    // Use Google's text embedding model
    model := client.EmbeddingModel("text-embedding-004")
    
    return &Embedder{
        client: client,
        model:  model,
    }, nil
}

// EmbedChunks generates embeddings for a batch of code chunks
func (e *Embedder) EmbedChunks(ctx context.Context, chunks []CodeChunk) ([][]float32, error) {
    embeddings := make([][]float32, len(chunks))
    
    // Process in batches to respect rate limits
    batchSize := 100
    for i := 0; i < len(chunks); i += batchSize {
        end := i + batchSize
        if end > len(chunks) {
            end = len(chunks)
        }
        
        batch := chunks[i:end]
        
        // Create embedding content for each chunk
        // Include: package, function signature, and key parts of content
        for j, chunk := range batch {
            text := formatChunkForEmbedding(chunk)
            
            resp, err := e.model.EmbedContent(ctx, genai.Text(text))
            if err != nil {
                return nil, err
            }
            
            embeddings[i+j] = resp.Embedding.Values
        }
    }
    
    return embeddings, nil
}

// EmbedQuery generates an embedding for a search query
func (e *Embedder) EmbedQuery(ctx context.Context, query string) ([]float32, error) {
    resp, err := e.model.EmbedContent(ctx, genai.Text(query))
    if err != nil {
        return nil, err
    }
    return resp.Embedding.Values, nil
}

// formatChunkForEmbedding creates a text representation optimized for embedding
func formatChunkForEmbedding(chunk CodeChunk) string {
    // Format: "Package: X | Function: Y | Imports: Z | Code: ..."
    // Truncate content if too long (embedding models have limits)
    return fmt.Sprintf(
        "Package: %s\nType: %s\nName: %s\nSignature: %s\nImports: %s\nCode:\n%s",
        chunk.Package,
        chunk.Type,
        chunk.Name,
        chunk.Signature,
        strings.Join(chunk.Imports, ", "),
        truncate(chunk.Content, 2000),
    )
}

func (e *Embedder) Close() error {
    return e.client.Close()
}
```

### 3. Vector Store (`store.go`)

Simple in-memory vector storage with cosine similarity search.

```go
package rag

import (
    "math"
    "sort"
)

// VectorStore holds chunks and their embeddings in memory
type VectorStore struct {
    chunks     []CodeChunk
    embeddings [][]float32
}

// NewVectorStore creates an empty vector store
func NewVectorStore() *VectorStore {
    return &VectorStore{}
}

// Add adds chunks with their embeddings to the store
func (vs *VectorStore) Add(chunks []CodeChunk, embeddings [][]float32) {
    vs.chunks = append(vs.chunks, chunks...)
    vs.embeddings = append(vs.embeddings, embeddings...)
}

// SearchResult represents a search result with similarity score
type SearchResult struct {
    Chunk      CodeChunk
    Similarity float32
}

// Search finds the top-K most similar chunks to the query embedding
func (vs *VectorStore) Search(queryEmbedding []float32, topK int) []SearchResult {
    type scoredChunk struct {
        index      int
        similarity float32
    }
    
    // Calculate similarity for all chunks
    scores := make([]scoredChunk, len(vs.chunks))
    for i, embedding := range vs.embeddings {
        scores[i] = scoredChunk{
            index:      i,
            similarity: cosineSimilarity(queryEmbedding, embedding),
        }
    }
    
    // Sort by similarity (descending)
    sort.Slice(scores, func(i, j int) bool {
        return scores[i].similarity > scores[j].similarity
    })
    
    // Return top-K
    if topK > len(scores) {
        topK = len(scores)
    }
    
    results := make([]SearchResult, topK)
    for i := 0; i < topK; i++ {
        results[i] = SearchResult{
            Chunk:      vs.chunks[scores[i].index],
            Similarity: scores[i].similarity,
        }
    }
    
    return results
}

// cosineSimilarity calculates the cosine similarity between two vectors
func cosineSimilarity(a, b []float32) float32 {
    if len(a) != len(b) {
        return 0
    }
    
    var dotProduct, normA, normB float32
    for i := range a {
        dotProduct += a[i] * b[i]
        normA += a[i] * a[i]
        normB += b[i] * b[i]
    }
    
    if normA == 0 || normB == 0 {
        return 0
    }
    
    return dotProduct / (float32(math.Sqrt(float64(normA))) * float32(math.Sqrt(float64(normB))))
}

// Size returns the number of chunks in the store
func (vs *VectorStore) Size() int {
    return len(vs.chunks)
}
```

### 4. Retriever (`retriever.go`)

High-level interface for building index and retrieving relevant code.

```go
package rag

import (
    "context"
    "fmt"
    "strings"
)

// Retriever manages the RAG pipeline
type Retriever struct {
    chunker  *Chunker
    embedder *Embedder
    store    *VectorStore
}

// NewRetriever creates a new retriever
func NewRetriever(repoPath string, embedder *Embedder) *Retriever {
    return &Retriever{
        chunker:  NewChunker(repoPath),
        embedder: embedder,
        store:    NewVectorStore(),
    }
}

// BuildIndex indexes the entire repository
func (r *Retriever) BuildIndex(ctx context.Context) error {
    fmt.Println("   Chunking codebase...")
    chunks, err := r.chunker.ChunkRepository()
    if err != nil {
        return fmt.Errorf("failed to chunk repository: %w", err)
    }
    fmt.Printf("   Created %d chunks\n", len(chunks))
    
    fmt.Println("   Generating embeddings...")
    embeddings, err := r.embedder.EmbedChunks(ctx, chunks)
    if err != nil {
        return fmt.Errorf("failed to embed chunks: %w", err)
    }
    
    r.store.Add(chunks, embeddings)
    fmt.Printf("   Indexed %d chunks\n", r.store.Size())
    
    return nil
}

// RetrieveRelevantCode finds code relevant to a CVE query
func (r *Retriever) RetrieveRelevantCode(ctx context.Context, cveDescription string, affectedPackages []string, topK int) ([]SearchResult, error) {
    // Build a query that combines CVE info with package names
    query := buildSearchQuery(cveDescription, affectedPackages)
    
    // Embed the query
    queryEmbedding, err := r.embedder.EmbedQuery(ctx, query)
    if err != nil {
        return nil, fmt.Errorf("failed to embed query: %w", err)
    }
    
    // Search for similar chunks
    results := r.store.Search(queryEmbedding, topK)
    
    return results, nil
}

// buildSearchQuery creates an optimized search query
func buildSearchQuery(cveDescription string, affectedPackages []string) string {
    var parts []string
    
    // Add affected package names (important for matching imports)
    if len(affectedPackages) > 0 {
        parts = append(parts, "Packages: "+strings.Join(affectedPackages, ", "))
    }
    
    // Add CVE description (truncated)
    if cveDescription != "" {
        desc := cveDescription
        if len(desc) > 500 {
            desc = desc[:500]
        }
        parts = append(parts, "Vulnerability: "+desc)
    }
    
    return strings.Join(parts, "\n")
}

// FormatResultsForPrompt formats search results for inclusion in the Gemini prompt
func FormatResultsForPrompt(results []SearchResult, maxTokens int) string {
    var sb strings.Builder
    currentSize := 0
    
    sb.WriteString("## Relevant ECK Source Code\n\n")
    sb.WriteString("The following code snippets from ECK are most relevant to this CVE:\n\n")
    
    for i, result := range results {
        // Estimate tokens (rough: 4 chars per token)
        chunkSize := len(result.Chunk.Content) / 4
        if currentSize + chunkSize > maxTokens {
            sb.WriteString(fmt.Sprintf("\n... and %d more relevant chunks (truncated for length)\n", len(results)-i))
            break
        }
        
        sb.WriteString(fmt.Sprintf("### %s - %s (similarity: %.2f)\n\n", 
            result.Chunk.FilePath, 
            result.Chunk.Name,
            result.Similarity))
        
        sb.WriteString(fmt.Sprintf("**Package**: %s\n", result.Chunk.Package))
        sb.WriteString(fmt.Sprintf("**Imports**: %s\n\n", strings.Join(result.Chunk.Imports, ", ")))
        
        sb.WriteString("```go\n")
        sb.WriteString(result.Chunk.Content)
        sb.WriteString("\n```\n\n")
        
        currentSize += chunkSize
    }
    
    return sb.String()
}
```

### 5. Integration with Existing Code

Update `main.go` to add RAG flag and integration:

```go
var (
    // ... existing flags ...
    useRAG       bool
    ragTopK      int
)

func init() {
    // ... existing flags ...
    rootCmd.Flags().BoolVar(&useRAG, "use-rag", false, "Use RAG to include relevant source code in analysis")
    rootCmd.Flags().IntVar(&ragTopK, "rag-top-k", 10, "Number of code chunks to retrieve")
}

func runTriage(cmd *cobra.Command, args []string) error {
    // ... existing code ...
    
    // Step X: Build RAG index and retrieve relevant code (if enabled)
    var ragResults []rag.SearchResult
    if useRAG && geminiAPIKey != "" {
        fmt.Printf("\nğŸ“š Building code index for RAG...\n")
        
        embedder, err := rag.NewEmbedder(ctx, geminiAPIKey)
        if err != nil {
            fmt.Printf("   âš ï¸  Failed to initialize embedder: %v\n", err)
        } else {
            defer embedder.Close()
            
            retriever := rag.NewRetriever(eckRepoPath, embedder)
            if err := retriever.BuildIndex(ctx); err != nil {
                fmt.Printf("   âš ï¸  Failed to build index: %v\n", err)
            } else {
                ragResults, err = retriever.RetrieveRelevantCode(ctx, 
                    cveInfo.Description, 
                    cveInfo.AffectedPackages, 
                    ragTopK)
                if err != nil {
                    fmt.Printf("   âš ï¸  Failed to retrieve code: %v\n", err)
                } else {
                    fmt.Printf("   âœ… Retrieved %d relevant code chunks\n", len(ragResults))
                }
            }
        }
    }
    
    // Pass ragResults to LLM analyzer
    llmResult, err = analyzer.Analyze(ctx, cveInfo, depResult, vulnResult, ragResults)
}
```

Update `analyzer.go` to include retrieved code in prompt:

```go
func buildAnalysisPrompt(cveInfo *parser.CVEInfo, depResult *deps.CheckResult, 
                         vulnResult *vulncheck.Result, ragResults []rag.SearchResult) string {
    // ... existing prompt building ...
    
    // Add retrieved code context
    if len(ragResults) > 0 {
        sb.WriteString(rag.FormatResultsForPrompt(ragResults, 10000)) // ~10k tokens of code
    }
    
    // ... rest of prompt ...
}
```

## CLI Usage

```bash
# Without RAG (current behavior)
./cve-triage --issue-body="CVE-2024-..." --dry-run

# With RAG enabled
./cve-triage --issue-body="CVE-2024-..." --use-rag --dry-run

# With custom top-K
./cve-triage --issue-body="CVE-2024-..." --use-rag --rag-top-k=20 --dry-run
```

## GitHub Actions Integration

```yaml
- name: Run CVE Triage with RAG
  env:
    GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
  run: |
    cd hack/cve-triage
    ./cve-triage \
      --issue-number=${{ github.event.issue.number }} \
      --issue-body="${{ github.event.issue.body }}" \
      --use-rag \
      --rag-top-k=15 \
      --repo-path=../..
```

## Cost Estimates

| Component | Per Run Cost |
|-----------|--------------|
| Embedding ECK codebase (~500k tokens) | ~$0.005 |
| Query embedding | ~$0.00001 |
| Gemini analysis (with code context) | ~$0.01-0.02 |
| **Total per CVE triage** | **~$0.02** |

## Performance

| Metric | Estimate |
|--------|----------|
| Index build time | 2-3 minutes |
| Query time | <100ms |
| Memory usage | ~50MB (embeddings) |

## Future Enhancements

1. **Persistent Index**: Save/load index to avoid rebuilding each run
2. **Incremental Updates**: Only re-embed changed files
3. **Hybrid Search**: Combine embedding search with keyword matching
4. **Multi-Query**: Generate multiple queries from CVE for better recall

## Dependencies

No new external dependencies required - uses existing:
- `github.com/google/generative-ai-go` (already in go.mod)
- Go standard library (`go/ast`, `go/parser`, `go/token`)

